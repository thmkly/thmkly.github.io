<!DOCTYPE html>

<html>
<head>

<script src="https://unpkg.com/dayjs@1/dayjs.min.js"></script>
<script src="https://unpkg.com/dayjs@1/plugin/utc.js"></script>
<script src="https://unpkg.com/dayjs@1/plugin/timezone.js"></script>
<script>
  dayjs.extend(dayjs_plugin_utc);
  dayjs.extend(dayjs_plugin_timezone);
</script>

  <meta charset="utf-8" />
  <title>A Soundmap of the PCT, Stereo 2023</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link href="https://api.mapbox.com/mapbox-gl-js/v3.8.0/mapbox-gl.css" rel="stylesheet" />
<style>
  body {
    margin: 0;
    padding: 0;
    font-family: helvetica, sans-serif;
  }

  #map {
    position: absolute;
    top: 0;
    bottom: 0;
    width: 100%;
  }

  /* Playlist Styles */
  .playlist-wrapper {
    position: absolute;
    top: 30px;
    left: 10px;
    width: 350px;
    max-height: 90vh;
    border-radius: 5px;
    box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
    background-color: rgba(255, 255, 255, 0.75);
    font-family: helvetica;
    font-size: small;
    display: flex;
    flex-direction: column;
    align-items: stretch;
    z-index: 2;
    transition: transform 0.3s ease;
  }

  .playlist-wrapper.collapsed {
    transform: translateX(-360px);
  }

  .playlist-toggle {
    position: absolute;
    right: -20px;
    top: 50%;
    transform: translateY(-50%);
    width: 20px;
    height: 50px;
    background-color: rgba(255, 255, 255, 0.75);
    border: none;
    border-radius: 0 5px 5px 0;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 12px;
    color: #333;
    box-shadow: 2px 0 5px rgba(0, 0, 0, 0.2);
    z-index: 3;
    transition: background-color 0.2s;
    opacity: 0;
    transition: opacity 0.3s ease, background-color 0.2s;
  }

  .playlist-toggle.visible {
    opacity: 1;
  }

  .playlist-toggle:hover {
    background-color: rgba(255, 255, 255, 0.9);
  }

  .playlist-wrapper:not(.collapsed) .playlist-toggle {
    background-color: transparent;
    box-shadow: none;
  }

  .playlist {
    overflow-y: auto;
    max-height: 85vh;
    padding: 5px;
    cursor: grab;
    user-select: none;
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
  }

  .playlist.dragging {
    cursor: grabbing;
  }

  .scroll-arrow {
    text-align: center;
    font-size: 12px;
    color: black;
    padding: 4px 0;
    user-select: none;
    cursor: pointer;
    display: none;
  }

  .track {
    cursor: pointer;
    padding: 5px;
    margin: 1px;
    border-bottom: 1px solid #ccc;
    display: flex;
    justify-content: space-between;
    align-items: center;
  }

  .track:hover {
    background-color: #f0f0f0;
  }

  .active-track {
    background-color: #d0d0d0;
  }

  .track-info {
    flex: 1;
  }

  .track-mile {
    font-size: 0.8em;
    color: #666;
    min-width: 40px;
    text-align: right;
  }

  /* Control Panel */
  .control-panel {
    position: absolute;
    top: 25px;
    right: 25px;
    background-color: rgba(255, 255, 255, 0.9);
    border-radius: 5px;
    box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
    padding: 10px;
    z-index: 2;
    display: flex;
    flex-direction: column;
    gap: 8px;
  }

  .control-row {
    display: flex;
    gap: 8px;
  }

  .control-btn {
    padding: 6px 12px;
    border: 1px solid #ccc;
    border-radius: 3px;
    background-color: white;
    cursor: pointer;
    font-size: 12px;
    transition: all 0.2s;
  }

  .control-btn:hover {
    background-color: #f0f0f0;
  }

  .control-btn.active {
    background-color: #5c3a2e;
    color: white;
    border-color: #5c3a2e;
  }

  .sort-controls {
    display: flex;
    gap: 4px;
    align-items: center;
  }

  .sort-btn {
    padding: 4px 8px;
    font-size: 11px;
  }

  .random-control {
    display: flex;
    align-items: center;
    gap: 6px;
    margin-left: 8px;
  }

  .random-label {
    font-size: 11px;
    color: #333;
  }

  .toggle-switch {
    position: relative;
    width: 36px;
    height: 18px;
    background-color: #ccc;
    border-radius: 9px;
    cursor: pointer;
    transition: background-color 0.3s;
  }

  .toggle-switch.active {
    background-color: #5c3a2e;
  }

  .toggle-slider {
    position: absolute;
    top: 2px;
    left: 2px;
    width: 14px;
    height: 14px;
    background-color: white;
    border-radius: 50%;
    transition: transform 0.3s;
  }

  .toggle-switch.active .toggle-slider {
    transform: translateX(18px);
  }

  /* Mini Info Boxes */
  .mini-infobox {
    position: absolute;
    background: rgba(255, 255, 255, 0.85);
    border: 1px solid #ccc;
    border-radius: 4px;
    padding: 4px 8px;
    font-size: 11px;
    color: #333;
    pointer-events: auto;
    cursor: pointer;
    z-index: 1;
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
    display: flex;
    align-items: center;
    gap: 4px;
    max-width: 200px;
    white-space: nowrap;
    overflow: visible;
    transition: background-color 0.2s;
  }

  .mini-infobox:hover {
    background: rgba(240, 240, 240, 0.9);
  }

  .mini-infobox-title {
    flex: 1;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
    cursor: pointer;
  }

  .play-icon {
    width: 0;
    height: 0;
    border-left: 6px solid #5c3a2e;
    border-top: 4px solid transparent;
    border-bottom: 4px solid transparent;
    flex-shrink: 0;
    cursor: pointer;
  }

  .play-icon:hover {
    border-left-color: #4a2e24;
  }

  /* Popup Controls */
  .popup-controls {
    display: flex;
    justify-content: space-between;
    align-items: center;
    gap: 10px;
    margin: 8px 0;
    position: relative;
  }

  .nav-arrow {
    background: transparent;
    color: #333;
    border: 1px solid #ccc;
    border-radius: 3px;
    padding: 8px 12px;
    cursor: pointer;
    font-size: 14px;
    font-weight: bold;
    transition: all 0.2s;
    min-width: 40px;
    display: flex;
    align-items: center;
    justify-content: center;
  }

  .nav-arrow:hover {
    background: #f0f0f0;
    color: #000;
  }

  .nav-arrow:disabled {
    background: transparent;
    color: #ccc;
    border-color: #eee;
    cursor: not-allowed;
  }

  .audio-container {
    flex: 1;
    margin: 0 10px;
  }

  /* Cluster Playlist */
  .cluster-playlist {
    position: absolute;
    background: rgba(255, 255, 255, 0.85);
    border: 1px solid #ccc;
    border-radius: 4px;
    padding: 4px;
    font-size: 11px;
    max-width: 250px;
    max-height: 200px;
    overflow-y: auto;
    z-index: 1000;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
  }

  .cluster-item {
    padding: 4px 8px;
    cursor: pointer;
    border-bottom: 1px solid #eee;
    display: flex;
    align-items: center;
    gap: 4px;
    transition: background-color 0.2s;
    border-radius: 2px;
    margin: 1px 0;
  }

  .cluster-item:hover {
    background-color: rgba(240, 240, 240, 0.9);
  }

  .cluster-item:last-child {
    border-bottom: none;
  }

  .cluster-item-title {
    flex: 1;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
  }

  .cluster-item .play-icon {
    width: 0;
    height: 0;
    border-left: 5px solid #5c3a2e;
    border-top: 3px solid transparent;
    border-bottom: 3px solid transparent;
    flex-shrink: 0;
  }

  .cluster-item:hover .play-icon {
    border-left-color: #4a2e24;
  }

  /* Map Controls */
  .mapboxgl-canvas {
    cursor: grab;
  }

  .mapboxgl-popup {
    z-index: 10 !important;
  }

  .mapboxgl-popup-content {
    opacity: 0.8;
    transition: opacity 0.3s ease;
    min-width: 320px;
    max-width: 90vw;
    box-sizing: border-box;
  }

  .mapboxgl-popup-close-button:focus {
    outline: none;
    box-shadow: none;
  }

  .loading-placeholder {
    text-align: center;
    color: #555;
    padding: 8px;
  }

  /* Notification Messages */
  .notification {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: rgba(0, 0, 0, 0.7);
    color: white;
    padding: 12px 20px;
    border-radius: 6px;
    font-size: 14px;
    z-index: 10000;
    pointer-events: none;
    opacity: 0;
    transition: opacity 0.3s ease;
  }

  .notification.show {
    opacity: 1;
  }

  /* Responsive adjustments */
  @media (max-width: 768px) {
    .playlist-wrapper {
      width: 300px;
    }
    
    .control-panel {
      right: 10px;
      top: 10px;
    }
    
    .mini-infobox {
      max-width: 150px;
    }
  }

  /* Fullscreen styles */
  .fullscreen-active {
    position: fixed !important;
    top: 0 !important;
    left: 0 !important;
    width: 100vw !important;
    height: 100vh !important;
    z-index: 9999 !important;
  }

  /* Hide audio focus outline */
  audio:focus {
    outline: none;
  }
</style>

<script>
  // Fixed Pacific timestamp parser for ISO format with proper DST handling
  function parsePacific(ts) {
    if (!ts) return dayjs();
    
    // Handle both ISO format (2023-05-06T16:55:00.000Z) and M/D/YYYY format
    let parsed;
    if (ts.includes('T') && ts.includes('Z')) {
      // ISO format - parse as UTC then convert to Pacific
      parsed = dayjs.utc(ts).tz("America/Los_Angeles");
    } else {
      // M/D/YYYY H:mm:ss format - treat as Pacific local time
      parsed = dayjs(ts, "M/D/YYYY H:mm:ss").tz("America/Los_Angeles", true);
    }
    
    return parsed;
  }

  // Helper to determine if date is in DST
  function isDST(date) {
    const year = date.getFullYear();
    
    // DST starts second Sunday in March
    const march = new Date(year, 2, 1); // March 1st
    const firstSunday = march.getDate() + (7 - march.getDay()) % 7;
    const secondSunday = firstSunday + 7;
    const dstStart = new Date(year, 2, secondSunday, 2, 0, 0); // 2 AM
    
    // DST ends first Sunday in November
    const november = new Date(year, 10, 1); // November 1st
    const firstSundayNov = november.getDate() + (7 - november.getDay()) % 7;
    const dstEnd = new Date(year, 10, firstSundayNov, 2, 0, 0); // 2 AM
    
    return date >= dstStart && date < dstEnd;
  }
</script>

</head>
<body>
  <div id="map"></div>
  
  <div class="playlist-wrapper" id="playlistWrapper">
    <button class="playlist-toggle" id="playlistToggle" title="Collapse playlist">◀</button>
    <div class="scroll-arrow up" id="scrollUp" title="Scroll up">▲</div>
    <div class="playlist" id="playlist">
      <div class="loading-placeholder">loading recordings...</div>
    </div>
    <div class="scroll-arrow down" id="scrollDown" title="Scroll down">▼</div>
  </div>

  <div class="control-panel">
    <div class="control-row">
      <button class="control-btn" id="resetMapBtn" title="Reset view and stop playback">Reset Map</button>
      <button class="control-btn" id="fullscreenBtn" title="Fullscreen on/off">Fullscreen</button>
      <button class="control-btn" id="terrain3dBtn" title="3D terrain on/off">3D Terrain</button>
    </div>
    <div class="sort-controls">
      <button class="control-btn sort-btn active" id="sortNobo" title="Northbound playlist">NOBO →</button>
      <button class="control-btn sort-btn" id="sortSobo" title="Southbound playlist">SOBO ↓</button>
      <button class="control-btn sort-btn" id="sortDate" title="Chronological playlist">STEREO ↻</button>
      <div class="random-control">
        <span class="random-label">Random</span>
        <div class="toggle-switch" id="randomToggle" title="Random on/off">
          <div class="toggle-slider"></div>
        </div>
      </div>
    </div>
  </div>

  <div class="notification" id="notification"></div>

  <script src="https://api.mapbox.com/mapbox-gl-js/v3.8.0/mapbox-gl.js"></script>
  <script src="config.js"></script>
  <script>
    // Configuration
    const CONFIG = {
      MAPBOX_TOKEN: window.MAPBOX_CONFIG?.token || 'pk.eyJ1IjoidGhta2x5IiwiYSI6ImNseXVyMjhueDA3YTQybW9mcHJrZGJ3YnEifQ.Nv-LsNg5eKIE6SeOVVJpYg',
      GOOGLE_SCRIPT_URL: 'https://script.google.com/macros/s/AKfycbygcwJ8ms4Zpq1BeGM_jQTEuajvoYw-A5-nkoTMZ5FBPfOP2DyORWfDuET2TEhXarfd/exec',
      DEFAULT_CENTER: [-122.50276, 41.31727],
      getDefaultZoom: () => {
        const screenWidth = window.screen.width;
        const screenHeight = window.screen.height;
        
        // Detect browsers that might report altered screen dimensions
        const isBrave = navigator.brave && navigator.brave.isBrave;
        const isFirefox = navigator.userAgent.toLowerCase().includes('firefox');
        const isTor = navigator.userAgent.toLowerCase().includes('tor');
        
        // Some browsers alter screen dimensions for privacy or have inconsistent reporting
        const hasUnreliableScreenData = isBrave || isTor || 
          (isFirefox && screenWidth === 1366 && screenHeight === 768) || // Firefox often defaults to this
          screenWidth === 1024 || screenHeight === 768; // Common privacy screen sizes
        
        // Calculate diagonal pixel resolution
        const diagonalPixels = Math.sqrt(screenWidth * screenWidth + screenHeight * screenHeight);
        
        // Reference points based on your current preferences:
        // 13" MacBook Air M3: zoom = 4.4
        // 27" monitor: zoom = 4.95
        
        if (hasUnreliableScreenData) {
          // Fallback logic for browsers with unreliable screen data
          // Use viewport dimensions as backup indicator
          const viewportWidth = window.innerWidth;
          const viewportHeight = window.innerHeight;
          const viewportDiagonal = Math.sqrt(viewportWidth * viewportWidth + viewportHeight * viewportHeight);
          
          if (viewportDiagonal > 2800) {
            return 4.2; // Large desktop/high-res
          } else if (viewportDiagonal > 2000) {
            return 4.95; // Desktop equivalent - adjusted threshold for 27" monitors  
          } else if (viewportDiagonal > 1800) {
            return 4.45; // Laptop equivalent - fine-tuned for Brave on 13"
          } else if (viewportDiagonal > 1400) {
            return 4.5; // Standard laptop
          } else {
            return 4.8; // Smaller screens/mobile
          }
        } else {
          // Safari/Chrome and other browsers with reliable screen data
          // Use your exact measurements for interpolation
          const ref1 = { diagonal: 3037, zoom: 4.4 };  // 13" MacBook Air M3 (2560x1664)
          const ref2 = { diagonal: 2203, zoom: 4.95 }; // 27" monitor (1920x1080)
          
          // Calculate zoom using linear interpolation between reference points
          if (diagonalPixels <= ref2.diagonal) {
            // Smaller/lower-res than 27" monitor - extrapolate to higher zoom
            const slope = (ref2.zoom - ref1.zoom) / (ref2.diagonal - ref1.diagonal);
            return Math.min(5.5, ref2.zoom + slope * (ref2.diagonal - diagonalPixels));
          } else if (diagonalPixels >= ref1.diagonal) {
            // Higher-res than MacBook Air - extrapolate to lower zoom  
            const slope = (ref2.zoom - ref1.zoom) / (ref2.diagonal - ref1.diagonal);
            return Math.max(4.0, ref1.zoom + slope * (diagonalPixels - ref1.diagonal));
          } else {
            // Between the two reference points - interpolate
            const ratio = (diagonalPixels - ref2.diagonal) / (ref1.diagonal - ref2.diagonal);
            return ref2.zoom + ratio * (ref1.zoom - ref2.zoom);
          }
        }
      },
      ZOOM_2D: 10,
      ZOOM_3D: 14
    };

    // Notification System
    function showNotification(message, duration = 3000) {
      const notification = document.getElementById('notification');
      notification.textContent = message;
      notification.classList.add('show');
      setTimeout(() => {
        notification.classList.remove('show');
      }, duration);
    }

    // Enhanced Atmospheric Lighting System
    class AtmosphereController {
      constructor() {
        this.currentConditions = null;
        this.transitionInProgress = false;
      }

      // Calculate accurate sun position using proper solar algorithms
      calculateSunPosition(date, lat, lng) {
        // Parse the Pacific time correctly
        const pacificDate = parsePacific(date);
        const jsDate = pacificDate.toDate();
        
        console.log('Calculating sun position for:', {
          input: date,
          pacificFormatted: pacificDate.format('YYYY-MM-DD HH:mm:ss'),
          pacificTime: pacificDate.format('HH:mm'),
          isDST: isDST(jsDate),
          lat, lng
        });
        
        // Get local time in Pacific timezone
        const hours = jsDate.getHours();
        const minutes = jsDate.getMinutes();
        const timeDecimal = hours + minutes / 60;
        
        // Julian day calculation
        const jd = this.getJulianDay(jsDate);
        const n = jd - 2451545.0;
        
        // Solar longitude calculations
        const L = (280.460 + 0.9856474 * n) % 360;
        const g = this.toRad((357.528 + 0.9856003 * n) % 360);
        const lambda = this.toRad(L + 1.915 * Math.sin(g) + 0.020 * Math.sin(2 * g));
        
        // Sun's declination
        const sinDelta = Math.sin(this.toRad(23.45)) * Math.sin(lambda);
        const delta = Math.asin(sinDelta);
        
        // Hour angle calculation - corrected for local time
        const hourAngle = this.toRad(15 * (timeDecimal - 12));
        
        // Solar position calculations
        const latRad = this.toRad(lat);
        const sinAltitude = Math.sin(latRad) * Math.sin(delta) + 
                           Math.cos(latRad) * Math.cos(delta) * Math.cos(hourAngle);
        const altitude = this.toDeg(Math.asin(Math.max(-1, Math.min(1, sinAltitude))));
        
        // Azimuth calculation
        const cosAzimuth = (Math.sin(delta) - Math.sin(latRad) * sinAltitude) / 
                          (Math.cos(latRad) * Math.cos(Math.asin(Math.max(-1, Math.min(1, sinAltitude)))));
        let azimuth = this.toDeg(Math.acos(Math.max(-1, Math.min(1, cosAzimuth))));
        
        // Adjust azimuth for afternoon (when hour angle > 0)
        if (hourAngle > 0) {
          azimuth = 360 - azimuth;
        }
        
        console.log(`Solar calculation: Pacific time: ${timeDecimal.toFixed(2)}h (${hours}:${minutes.toString().padStart(2, '0')}), Altitude: ${altitude.toFixed(1)}°, Azimuth: ${azimuth.toFixed(1)}°`);
        
        return { altitude, azimuth };
      }
      
      getJulianDay(date) {
        // Corrected Julian day calculation
        const year = date.getFullYear();
        const month = date.getMonth() + 1;
        const day = date.getDate();
        const hours = date.getHours();
        const minutes = date.getMinutes();
        const seconds = date.getSeconds();
        
        // Standard Julian day calculation
        let a = Math.floor((14 - month) / 12);
        let y = year + 4800 - a;
        let m = month + 12 * a - 3;
        
        let jdn = day + Math.floor((153 * m + 2) / 5) + 365 * y + 
                  Math.floor(y / 4) - Math.floor(y / 100) + Math.floor(y / 400) - 32045;
        
        // Add time component (fraction of day)
        const timeDecimal = (hours + minutes / 60 + seconds / 3600) / 24;
        
        return jdn + timeDecimal - 0.5;
      }

      getElevationEffect(mile) {
        // PCT elevation profile approximation (in feet)
        let elevation = 2500; // Default
        
        if (mile && !isNaN(parseFloat(mile))) {
          const m = parseFloat(mile);
          // More detailed PCT elevation profile
          if (m < 100) elevation = 2500;           // Campo area
          else if (m < 300) elevation = 4000;      // Desert mountains
          else if (m < 500) elevation = 6000;      // San Bernardino/San Gabriel
          else if (m < 700) elevation = 5000;      // Mojave
          else if (m < 900) elevation = 8500;      // High Sierra
          else if (m < 1100) elevation = 7000;     // Northern Sierra
          else if (m < 1300) elevation = 5500;     // Northern California
          else if (m < 1500) elevation = 4500;     // Cascade Range
          else if (m < 1700) elevation = 5200;     // Northern California peaks
          else if (m < 1900) elevation = 4800;     // Oregon Cascades
          else if (m < 2100) elevation = 5500;     // Central Oregon peaks
          else if (m < 2300) elevation = 4200;     // Northern Oregon
          else if (m < 2500) elevation = 5800;     // Washington Cascades
          else if (m < 2650) elevation = 4000;     // Northern Washington
          else elevation = 3800;                   // Canadian border
        }
        
        // Higher elevation = clearer atmosphere, more intense colors
        const effect = 1 + (elevation - 2500) / 8000;
        return Math.min(Math.max(effect, 0.8), 1.6);
      }

      getTimePeriod(altitude) {
        // More precise time period determination
        if (altitude < -18) return 'astronomicalNight';
        if (altitude < -12) return 'astronomicalTwilight';
        if (altitude < -6) return 'nauticalTwilight';  
        if (altitude < -0.833) return 'civilTwilight'; // Actual sunrise/sunset altitude
        if (altitude < 6) return 'sunrise';
        if (altitude < 15) return 'goldenHour';
        if (altitude < 30) return 'morning';
        if (altitude < 60) return 'midday';
        return 'noon';
      }

      getSeason(date, lat) {
        const month = date.getMonth() + 1;
        const day = date.getDate();
        
        // More precise seasonal boundaries
        if ((month === 12 && day >= 21) || month <= 2 || (month === 3 && day < 20)) return 'winter';
        if ((month === 3 && day >= 20) || month <= 5 || (month === 6 && day < 21)) return 'spring';
        if ((month === 6 && day >= 21) || month <= 8 || (month === 9 && day < 23)) return 'summer';
        return 'autumn';
      }

      calculateColors(sunPos, period, season, elevationEffect) {
        const colors = {
          sky: '#87CEEB',
          fog: 'rgba(255, 255, 255, 0.4)',
          ambient: '#ffffff',
          horizon: '#E0F6FF'
        };

        // Enhanced period-based colors with smooth transitions
        const periodColors = {
          astronomicalNight: {
            sky: '#000814',
            fog: 'rgba(8, 15, 30, 0.8)',
            ambient: '#0a1929',
            horizon: '#001122'
          },
          astronomicalTwilight: {
            sky: '#1a237e',
            fog: 'rgba(26, 35, 78, 0.7)',
            ambient: '#283593',
            horizon: '#1a237e'
          },
          nauticalTwilight: {
            sky: '#3949ab',
            fog: 'rgba(57, 73, 171, 0.6)',
            ambient: '#3f51b5',
            horizon: '#303f9f'
          },
          civilTwilight: {
            sky: '#5c6bc0',
            fog: 'rgba(92, 107, 192, 0.5)',
            ambient: '#7986cb',
            horizon: '#9fa8da'
          },
          sunrise: {
            sky: '#ff6b47',
            fog: 'rgba(255, 120, 90, 0.3)',
            ambient: '#ff8a65',
            horizon: '#ffab91'
          },
          goldenHour: {
            sky: '#ffa726',
            fog: 'rgba(255, 193, 100, 0.25)',
            ambient: '#ffb74d',
            horizon: '#ffcc02'
          },
          morning: {
            sky: '#42a5f5',
            fog: 'rgba(150, 200, 255, 0.2)',
            ambient: '#64b5f6',
            horizon: '#90caf9'
          },
          midday: {
            sky: '#1e88e5',
            fog: 'rgba(120, 180, 255, 0.15)',
            ambient: '#42a5f5',
            horizon: '#81c784'
          },
          noon: {
            sky: '#1565c0',
            fog: 'rgba(100, 160, 255, 0.1)',
            ambient: '#1976d2',
            horizon: '#66bb6a'
          }
        };

        // Apply period colors
        Object.assign(colors, periodColors[period] || periodColors.midday);

        // Seasonal color temperature adjustments
        const seasonalAdjustments = {
          winter: { hueShift: -10, saturation: 0.85, brightness: 0.9 },
          spring: { hueShift: 5, saturation: 1.1, brightness: 1.05 },
          summer: { hueShift: 10, saturation: 1.15, brightness: 1.1 },
          autumn: { hueShift: 15, saturation: 1.1, brightness: 0.95 }
        };

        // Apply elevation effect (higher = clearer, more saturated)
        if (elevationEffect > 1.1) {
          const factor = Math.min(elevationEffect, 1.5);
          // High elevation gets more intense, clearer colors
          colors.sky = this.adjustColorIntensity(colors.sky, factor);
        }

        return colors;
      }

      adjustColorIntensity(hexColor, intensity) {
        // Simple color intensity adjustment
        if (!hexColor.startsWith('#')) return hexColor;
        
        const r = parseInt(hexColor.slice(1, 3), 16);
        const g = parseInt(hexColor.slice(3, 5), 16);
        const b = parseInt(hexColor.slice(5, 7), 16);
        
        // Increase saturation for high elevations
        const factor = Math.min(intensity, 1.3);
        const newR = Math.min(255, Math.round(r * factor));
        const newG = Math.min(255, Math.round(g * factor));
        const newB = Math.min(255, Math.round(b * factor));
        
        return `#${newR.toString(16).padStart(2, '0')}${newG.toString(16).padStart(2, '0')}${newB.toString(16).padStart(2, '0')}`;
      }

      calculateFog(sunPos, period, elevationEffect) {
        const baseFog = {
          range: [0.5, 10],
          color: 'white',
          'horizon-blend': 0.1,
          'high-color': '#87CEEB',
          'space-color': '#000033',
          'star-intensity': 0
        };

        // Time-based fog adjustments
        const fogProfiles = {
          astronomicalNight: { 
            range: [0.3, 8], 
            'horizon-blend': 0.02, 
            'star-intensity': 1.0,
            color: 'rgba(8, 15, 30, 0.8)',
            'space-color': '#000011'
          },
          astronomicalTwilight: { 
            range: [0.4, 9], 
            'horizon-blend': 0.04, 
            'star-intensity': 0.7,
            color: 'rgba(26, 35, 78, 0.7)'
          },
          nauticalTwilight: { 
            range: [0.5, 10], 
            'horizon-blend': 0.06, 
            'star-intensity': 0.4,
            color: 'rgba(57, 73, 171, 0.6)'
          },
          civilTwilight: { 
            range: [0.6, 11], 
            'horizon-blend': 0.08, 
            'star-intensity': 0.1,
            color: 'rgba(92, 107, 192, 0.5)'
          },
          sunrise: { 
            range: [0.3, 7], 
            'horizon-blend': 0.15, 
            'star-intensity': 0,
            color: 'rgba(255, 120, 90, 0.3)'
          },
          goldenHour: { 
            range: [0.4, 8], 
            'horizon-blend': 0.12, 
            'star-intensity': 0,
            color: 'rgba(255, 193, 100, 0.25)'
          },
          morning: { 
            range: [0.6, 12], 
            'horizon-blend': 0.1, 
            'star-intensity': 0,
            color: 'rgba(150, 200, 255, 0.2)'
          },
          midday: { 
            range: [0.8, 15], 
            'horizon-blend': 0.08, 
            'star-intensity': 0,
            color: 'rgba(120, 180, 255, 0.15)'
          },
          noon: { 
            range: [1.0, 18], 
            'horizon-blend': 0.05, 
            'star-intensity': 0,
            color: 'rgba(100, 160, 255, 0.1)'
          }
        };

        Object.assign(baseFog, fogProfiles[period] || fogProfiles.midday);
        
        // Elevation adjustment: less fog, clearer view at higher elevations
        // Ensure fog range doesn't exceed Mapbox limits (max 20)
        baseFog.range[0] = Math.min(19, Math.max(0.1, baseFog.range[0] * elevationEffect));
        baseFog.range[1] = Math.min(20, Math.max(baseFog.range[0] + 0.1, baseFog.range[1] * Math.min(elevationEffect * 1.2, 1.8)));

        return baseFog;
      }

      calculateLight(sunPos, period, season) {
        // Enhanced lighting based on accurate sun position
        let intensity = Math.max(0.1, Math.min(1.0, (sunPos.altitude + 20) / 80));
        
        // Period-specific intensity adjustments
        const periodIntensity = {
          astronomicalNight: 0.05,
          astronomicalTwilight: 0.1,
          nauticalTwilight: 0.2,
          civilTwilight: 0.4,
          sunrise: 0.7,
          goldenHour: 0.8,
          morning: 0.9,
          midday: 1.0,
          noon: 1.0
        };
        
        intensity *= periodIntensity[period] || 1.0;
        
        // Seasonal adjustments
        const seasonMultiplier = {
          winter: 0.85,
          spring: 0.95,
          summer: 1.1,
          autumn: 0.9
        };
        
        intensity *= seasonMultiplier[season] || 1.0;

        // Color temperature based on time of day
        const lightColors = {
          astronomicalNight: '#4466aa',
          astronomicalTwilight: '#6688cc',
          nauticalTwilight: '#88aaee',
          civilTwilight: '#aaccff',
          sunrise: '#ffaa66',
          goldenHour: '#ffcc88',
          morning: '#ffffff',
          midday: '#ffffff',
          noon: '#ffffff'
        };

        return {
          anchor: 'viewport',
          color: lightColors[period] || '#ffffff',
          intensity: intensity,
          position: [1.15, sunPos.azimuth, Math.max(5, sunPos.altitude)]
        };
      }

      // Get atmospheric conditions based on sun position, elevation, and time
      getAtmosphericConditions(track) {
        const pacificDate = parsePacific(track.timestamp);
        const jsDate = pacificDate.toDate();
        const lat = parseFloat(track.lat);
        const lng = parseFloat(track.lng);
        
        console.log('Processing atmospheric conditions for:', {
          track: track.name,
          timestamp: track.timestamp,
          pacificFormatted: pacificDate.format('YYYY-MM-DD HH:mm:ss'),
          coords: [lat, lng]
        });
        
        // Calculate sun position
        const sunPos = this.calculateSunPosition(track.timestamp, lat, lng);
        
        // Get elevation effect
        const elevationEffect = this.getElevationEffect(track.mile);
        
        // Determine time period and season
        const period = this.getTimePeriod(sunPos.altitude);
        const season = this.getSeason(jsDate, lat);
        
        // Calculate atmospheric colors and effects
        const colors = this.calculateColors(sunPos, period, season, elevationEffect);
        
        console.log('Atmospheric conditions determined:', {
          period,
          season,
          sunAltitude: sunPos.altitude.toFixed(1),
          sunAzimuth: sunPos.azimuth.toFixed(1),
          elevation: elevationEffect.toFixed(2)
        });
        
        return {
          sunPosition: sunPos,
          period,
          season,
          elevationEffect,
          colors,
          fogSettings: this.calculateFog(sunPos, period, elevationEffect),
          lightSettings: this.calculateLight(sunPos, period, season)
        };
      }

      applyAtmosphere(track) {
        if (!map || !track) return;
        
        const conditions = this.getAtmosphericConditions(track);
        this.currentConditions = conditions;
        
        console.log('Applying atmosphere for:', track.name, 'Period:', conditions.period);

        // Apply Mapbox Sky API
        if (typeof map.setSky === 'function') {
          try {
            map.setSky({
              'sky-type': 'atmosphere',
              'sky-atmosphere-sun': [conditions.sunPosition.azimuth, Math.max(0, conditions.sunPosition.altitude)],
              'sky-atmosphere-sun-intensity': this.getSunIntensity(conditions.period, conditions.sunPosition.altitude),
              'sky-atmosphere-color': conditions.colors.sky,
              'sky-gradient': [
                'interpolate',
                ['linear'],
                ['sky-radial-progress'],
                0.8,
                conditions.colors.horizon,
                1,
                conditions.colors.sky
              ],
              'sky-atmosphere-halo-color': this.getHaloColor(conditions.period),
              'sky-opacity': this.getSkyOpacity(conditions.period)
            });
            console.log('Sky API applied successfully');
          } catch (e) {
            console.warn('Sky API error:', e);
          }
        }

        // Apply Mapbox Fog API
        if (typeof map.setFog === 'function') {
          try {
            map.setFog(conditions.fogSettings);
            console.log('Fog API applied successfully');
          } catch (e) {
            console.warn('Fog API error:', e);
          }
        }

        // Apply lighting for 3D mode
        if (uiController.is3DEnabled && typeof map.setLight === 'function') {
          try {
            map.setLight(conditions.lightSettings);
            console.log('Light API applied successfully');
          } catch (e) {
            console.warn('Light API error:', e);
          }
        }

        // Fallback atmospheric effects for unsupported APIs
        if (typeof map.setSky !== 'function' || typeof map.setFog !== 'function') {
          this.applyFallbackAtmosphere(conditions);
        }
        
        // Enhanced notification with time and conditions
        const pacificDate = parsePacific(track.timestamp);
        const jsDate = pacificDate.toDate();
        const timeStr = pacificDate.format('H:mm');
        const timeDesc = conditions.period.replace(/([A-Z])/g, ' $1').toLowerCase().replace(/astronomical|nautical|civil/, '').trim();
        showNotification(`${timeStr} ${isDST(jsDate) ? 'PDT' : 'PST'} - ${timeDesc}`, 3000);
      }

      getSunIntensity(period, altitude) {
        const intensityMap = {
          astronomicalNight: 0.1,
          astronomicalTwilight: 0.3,
          nauticalTwilight: 0.5,
          civilTwilight: 1.0,
          sunrise: 8.0,
          goldenHour: 12.0,
          morning: 15.0,
          midday: 18.0,
          noon: 20.0
        };
        return intensityMap[period] || 15.0;
      }

      getHaloColor(period) {
        const haloColors = {
          astronomicalNight: '#001122',
          astronomicalTwilight: '#1a237e',
          nauticalTwilight: '#3949ab',
          civilTwilight: '#5c6bc0',
          sunrise: '#ff8a65',
          goldenHour: '#ffb74d',
          morning: '#81c784',
          midday: '#4fc3f7',
          noon: '#29b6f6'
        };
        return haloColors[period] || '#ffffff';
      }

      getSkyOpacity(period) {
        const opacityMap = {
          astronomicalNight: 0.8,
          astronomicalTwilight: 0.85,
          nauticalTwilight: 0.9,
          civilTwilight: 0.95,
          sunrise: 1.0,
          goldenHour: 1.0,
          morning: 1.0,
          midday: 1.0,
          noon: 1.0
        };
        return opacityMap[period] || 1.0;
      }

      // Enhanced fallback for browsers without full API support
      applyFallbackAtmosphere(conditions) {
        const existingOverlay = document.getElementById('atmosphere-overlay');
        if (existingOverlay) {
          existingOverlay.remove();
        }

        const overlay = document.createElement('div');
        overlay.id = 'atmosphere-overlay';
        overlay.style.cssText = `
          position: absolute;
          top: 0;
          left: 0;
          right: 0;
          bottom: 0;
          pointer-events: none;
          z-index: 1;
          transition: all 2s ease-in-out;
        `;
        
        // Enhanced gradients for different periods
        const overlayEffects = {
          astronomicalNight: 'radial-gradient(ellipse at center, rgba(0, 8, 20, 0.4), rgba(0, 8, 20, 0.7))',
          astronomicalTwilight: 'radial-gradient(ellipse at center, rgba(26, 35, 78, 0.3), rgba(26, 35, 78, 0.6))',
          nauticalTwilight: 'radial-gradient(ellipse at center, rgba(57, 73, 171, 0.25), rgba(57, 73, 171, 0.5))',
          civilTwilight: 'radial-gradient(ellipse at center, rgba(92, 107, 192, 0.2), rgba(92, 107, 192, 0.4))',
          sunrise: 'linear-gradient(to bottom, rgba(255, 107, 71, 0.3) 0%, rgba(255, 138, 101, 0.2) 40%, rgba(255, 171, 145, 0.1) 70%, transparent 100%)',
          goldenHour: 'linear-gradient(to bottom, rgba(255, 167, 38, 0.25) 0%, rgba(255, 183, 77, 0.15) 50%, rgba(255, 204, 2, 0.05) 80%, transparent 100%)',
          morning: 'radial-gradient(ellipse at center, rgba(66, 165, 245, 0.08), rgba(100, 181, 246, 0.03))',
          midday: 'radial-gradient(ellipse at center, transparent, rgba(30, 136, 229, 0.02))',
          noon: 'radial-gradient(ellipse at center, transparent, transparent)'
        };

        overlay.style.background = overlayEffects[conditions.period] || overlayEffects.midday;
        
        // Enhanced filter effects
        const filterEffects = {
          astronomicalNight: 'brightness(0.4) contrast(1.2) saturate(0.7) hue-rotate(-10deg)',
          astronomicalTwilight: 'brightness(0.5) contrast(1.15) saturate(0.8) hue-rotate(-5deg)',
          nauticalTwilight: 'brightness(0.6) contrast(1.1) saturate(0.9)',
          civilTwilight: 'brightness(0.75) contrast(1.05) saturate(0.95)',
          sunrise: 'brightness(1.1) contrast(1.1) saturate(1.3) sepia(0.15) hue-rotate(10deg)',
          goldenHour: 'brightness(1.15) contrast(1.05) saturate(1.2) sepia(0.1) hue-rotate(5deg)',
          morning: 'brightness(1.05) contrast(1.02) saturate(1.1)',
          midday: 'brightness(1.0) contrast(1.0) saturate(1.05)',
          noon: 'brightness(1.05) contrast(1.02) saturate(1.1)'
        };

        const mapContainer = document.getElementById('map');
        mapContainer.style.filter = filterEffects[conditions.period] || filterEffects.midday;
        mapContainer.style.transition = 'filter 2s ease-in-out';
        
        mapContainer.appendChild(overlay);
      }

      toRad(deg) {
        return deg * Math.PI / 180;
      }

      toDeg(rad) {
        return rad * 180 / Math.PI;
      }

      // Smooth transition when switching tracks
      transitionToTrack(track, duration = 2000) {
        if (this.transitionInProgress) return;
        this.transitionInProgress = true;

        // Apply new atmospheric conditions
        this.applyAtmosphere(track);

        setTimeout(() => {
          this.transitionInProgress = false;
        }, duration);
      }
    }

    // Audio Controller Class
    class AudioController {
      constructor() {
        this.currentAudio = null;
        this.currentIndex = -1;
        this.isPlaying = false;
        this.playMode = 'sequential';
        this.sortMode = 'nobo';
        this.playQueue = [];
        this.lastPlayNext = 0;
        this.playHistory = []; // Track play history for random mode
        this.setupWakeLock();
      }

      async setupWakeLock() {
        if ('wakeLock' in navigator) {
          try {
            this.wakeLock = await navigator.wakeLock.request('screen');
          } catch (err) {
            console.log('Wake lock not supported');
          }
        }
      }

      play(index, audioData) {
        if (this.currentAudio) {
          this.currentAudio.pause();
          this.currentAudio = null;
        }

        const track = audioData[index];
        if (!track) return;

        // Add to play history (keep last 50 for memory management)
        if (this.currentIndex !== -1 && this.currentIndex !== index) {
          this.playHistory.push(this.currentIndex);
          if (this.playHistory.length > 50) {
            this.playHistory.shift();
          }
        }

        this.currentIndex = index;
        this.isPlaying = true;

        const audio = document.createElement('audio');
        audio.src = track.audioUrl;
        audio.preload = 'auto';
        audio.controlsList = 'nodownload';
        audio.oncontextmenu = () => false;
        
        audio.addEventListener('ended', () => {
          this.playNext(audioData);
        });

        audio.addEventListener('error', () => {
          console.warn('Audio failed to load:', track.name, 'URL:', track.audioUrl);
          showNotification(`Audio failed to load: ${track.name}`, 3000);
        });

        this.currentAudio = audio;

        // mount into popup if container exists
        const popupContainer = document.getElementById('audioContainer');
        if (popupContainer) {
          popupContainer.innerHTML = '';
          popupContainer.appendChild(audio);
        }
        return audio;
      }

      togglePlayPause() {
        if (!this.currentAudio) return;
        
        if (this.currentAudio.paused) {
          this.currentAudio.play();
          this.isPlaying = true;
        } else {
          this.currentAudio.pause();
          this.isPlaying = false;
        }
      }

      playNext(audioData) {
        // Circuit breaker: prevent rapid successive calls
        const now = Date.now();
        if (this.lastPlayNext && (now - this.lastPlayNext) < 1000) {
          console.warn('PlayNext called too quickly, blocking to prevent loop');
          return;
        }
        this.lastPlayNext = now;

        let nextIndex;
        
        if (this.playMode === 'random') {
          nextIndex = Math.floor(Math.random() * audioData.length);
        } else {
          // Navigation based on sort mode:
          if (this.sortMode === 'date') {
            // STEREO: next goes down chronologically (towards newer/higher index)
            nextIndex = this.currentIndex + 1;
            if (nextIndex >= audioData.length) {
              nextIndex = 0; // Wrap to beginning (earliest)
            }
          } else if (this.sortMode === 'sobo') {
            // SOBO: next goes down the list (towards Mexico/higher index)
            nextIndex = this.currentIndex + 1;
            if (nextIndex >= audioData.length) {
              nextIndex = 0; // Wrap to top (Canada)
            }
          } else { // nobo mode
            // NOBO: next goes up the list (towards Canada/lower index)
            nextIndex = this.currentIndex - 1;
            if (nextIndex < 0) {
              nextIndex = audioData.length - 1; // Wrap to bottom (Mexico)
            }
          }
        }
        
        if (nextIndex !== this.currentIndex) {
          mapController.playAudio(nextIndex);
        }
      }

      playPrevious(audioData) {
        let prevIndex;
        
        if (this.playMode === 'random') {
          // In random mode, only go back if there's history
          if (this.playHistory.length === 0) {
            return; // Do nothing if no history
          }
          prevIndex = this.playHistory.pop();
        } else {
          // Navigation based on sort mode:
          if (this.sortMode === 'date') {
            // STEREO: prev goes up chronologically (towards older/lower index)
            prevIndex = this.currentIndex - 1;
            if (prevIndex < 0) {
              prevIndex = audioData.length - 1; // Wrap to end (latest)
            }
          } else if (this.sortMode === 'sobo') {
            // SOBO: prev goes up the list (towards Canada/lower index)
            prevIndex = this.currentIndex - 1;
            if (prevIndex < 0) {
              prevIndex = audioData.length - 1; // Wrap to bottom (Mexico)
            }
          } else { // nobo mode
            // NOBO: prev goes down the list (towards Mexico/higher index)
            prevIndex = this.currentIndex + 1;
            if (prevIndex >= audioData.length) {
              prevIndex = 0; // Wrap to top (Canada)
            }
          }
        }
        
        mapController.playAudio(prevIndex);
      }

      stop() {
        if (this.currentAudio) {
          this.currentAudio.pause();
          this.currentAudio = null;
        }
        this.isPlaying = false;
        this.currentIndex = -1;
      }
    }

    // UI Controller Class
    class UIController {
      constructor() {
        this.playlistExpanded = true;
        this.isFullscreen = false;
        this.is3DEnabled = false;
        this.miniInfoBoxes = [];
        this.clusterPlaylist = null;
        this.setupEventListeners();
      }

      setupEventListeners() {
        // Playlist toggle
        document.getElementById('playlistToggle').addEventListener('click', () => {
          this.togglePlaylist();
        });

        // Sort buttons
        document.querySelectorAll('.sort-btn').forEach(btn => {
          btn.addEventListener('click', (e) => {
            this.handleSortChange(e.target.id);
          });
        });

        // Random toggle
        document.getElementById('randomToggle').addEventListener('click', () => {
          audioController.playMode = audioController.playMode === 'random' ? 'sequential' : 'random';
          this.updateRandomToggle();
        });

        document.getElementById('resetMapBtn').addEventListener('click', () => {
          mapController.resetMap();
        });

        document.getElementById('fullscreenBtn').addEventListener('click', () => {
          this.toggleFullscreen();
        });

        document.getElementById('terrain3dBtn').addEventListener('click', () => {
          this.toggle3D();
        });

        // Global spacebar handler - prevent focus on audio elements
        document.addEventListener('keydown', (e) => {
          if (e.code === 'Space' && audioController.currentAudio) {
            e.preventDefault();
            audioController.togglePlayPause();
            // Blur any focused audio elements
            if (document.activeElement.tagName === 'AUDIO') {
              document.activeElement.blur();
            }
          }
        });

        // Scroll arrows
        const playlist = document.getElementById('playlist');
        const scrollUp = document.getElementById('scrollUp');
        const scrollDown = document.getElementById('scrollDown');

        playlist.addEventListener('scroll', () => this.updateScrollArrows());
        scrollUp.addEventListener('click', () => playlist.scrollBy({ top: -100, behavior: 'smooth' }));
        scrollDown.addEventListener('click', () => playlist.scrollBy({ top: 100, behavior: 'smooth' }));

        this.setupPlaylistDrag();
      }

      togglePlaylist() {
        const wrapper = document.getElementById('playlistWrapper');
        const toggle = document.getElementById('playlistToggle');
        
        this.playlistExpanded = !this.playlistExpanded;
        
        if (this.playlistExpanded) {
          wrapper.classList.remove('collapsed');
          toggle.textContent = '◀';
          toggle.title = 'Collapse playlist';
        } else {
          wrapper.classList.add('collapsed');
          toggle.textContent = '▶';
          toggle.title = 'Expand playlist';
        }
      }

      handleSortChange(sortId) {
        document.querySelectorAll('.sort-btn').forEach(btn => btn.classList.remove('active'));
        document.getElementById(sortId).classList.add('active');

        const sortMap = {
          'sortNobo': 'nobo',
          'sortSobo': 'sobo',
          'sortDate': 'date'
        };
        
        audioController.sortMode = sortMap[sortId];
        mapController.sortAndUpdatePlaylist();
      }

      updateRandomToggle() {
        const toggle = document.getElementById('randomToggle');
        toggle.classList.toggle('active', audioController.playMode === 'random');
      }

      toggleFullscreen() {
        const body = document.body;
        
        if (!this.isFullscreen) {
          if (body.requestFullscreen) {
            body.requestFullscreen();
          } else if (body.webkitRequestFullscreen) {
            body.webkitRequestFullscreen();
          } else if (body.msRequestFullscreen) {
            body.msRequestFullscreen();
          }
        } else {
          if (document.exitFullscreen) {
            document.exitFullscreen();
          } else if (document.webkitExitFullscreen) {
            document.webkitExitFullscreen();
          } else if (document.msExitFullscreen) {
            document.msExitFullscreen();
          }
        }
      }

      toggle3D() {
        this.is3DEnabled = !this.is3DEnabled;
        const btn = document.getElementById('terrain3dBtn');
        btn.classList.toggle('active', this.is3DEnabled);

        if (this.is3DEnabled) {
          // Add 3D terrain source (enhanced for v3)
          if (!map.getSource('mapbox-dem')) {
            map.addSource('mapbox-dem', {
              'type': 'raster-dem',
              'url': 'mapbox://mapbox.mapbox-terrain-dem-v1',
              'tileSize': 512,
              'maxzoom': 14
            });
          }
          
          // Set terrain with v3 optimizations
          map.setTerrain({ 
            'source': 'mapbox-dem', 
            'exaggeration': 1.5 
          });
          
          // Enhanced lighting for 3D in v3
          if (typeof map.setLight === 'function') {
            // Use current atmospheric conditions if available
            if (atmosphereController.currentConditions) {
              map.setLight(atmosphereController.currentConditions.lightSettings);
            } else {
              map.setLight({
                'anchor': 'viewport',
                'color': 'white',
                'intensity': 0.5,
                'position': [1.15, 210, 30]
              });
            }
          }
          
          // Wait for terrain to be ready, then apply 3D positioning
          const apply3DView = () => {
            if (audioController.currentIndex >= 0) {
              const currentTrack = mapController.audioData[audioController.currentIndex];
              if (currentTrack) {
                // Position for 3D view of current track
                const coords = [parseFloat(currentTrack.lng), parseFloat(currentTrack.lat)];
                map.flyTo({
                  center: coords,
                  zoom: CONFIG.ZOOM_3D,
                  pitch: 75,
                  bearing: 0,
                  duration: 2500,
                  easing: t => 1 - Math.pow(1 - t, 3)
                });
                
                // Apply atmospheric lighting for current track
                atmosphereController.applyAtmosphere(currentTrack);
              } else {
                // No valid track, just enable 3D at current location
                map.flyTo({
                  pitch: 75,
                  zoom: Math.max(map.getZoom(), CONFIG.ZOOM_3D),
                  duration: 2000
                });
              }
            } else {
              // No active track, just enable 3D at current location
              map.flyTo({
                pitch: 75,
                zoom: Math.max(map.getZoom(), CONFIG.ZOOM_3D),
                duration: 2000
              });
            }
            showNotification('3D view enabled - Hold Ctrl + drag to rotate', 4000);
          };
          
          // Wait a moment for terrain to initialize, then apply 3D view
          setTimeout(apply3DView, 300);
          
        } else {
          // Disable 3D
          map.setTerrain(null);
          if (typeof map.setLight === 'function') {
            map.setLight(null); // Reset lighting
          }
          map.flyTo({
            pitch: 0,
            duration: 1500
          });
          
          // Clean up terrain source
          setTimeout(() => {
            if (map.getSource('mapbox-dem')) {
              map.removeSource('mapbox-dem');
            }
          }, 1600);
          
          showNotification('3D view disabled', 2000);
        }
      }

      updateScrollArrows() {
        const playlist = document.getElementById('playlist');
        const scrollUp = document.getElementById('scrollUp');
        const scrollDown = document.getElementById('scrollDown');
        
        scrollUp.style.display = playlist.scrollTop > 0 ? 'block' : 'none';
        scrollDown.style.display = (playlist.scrollTop + playlist.clientHeight) < playlist.scrollHeight ? 'block' : 'none';
      }

      setupPlaylistDrag() {
        const playlist = document.getElementById('playlist');
        let dragging = false, startY, scrollStart, vel = 0, lastY = 0, lastTime = 0, raf;
        let dragStarted = false, preventClick = false;

        playlist.addEventListener('mousedown', e => {
          dragging = true;
          dragStarted = false;
          playlist.classList.add('dragging');
          startY = e.pageY;
          scrollStart = playlist.scrollTop;
          vel = 0;
          lastY = e.pageY;
          lastTime = Date.now();
          if (raf) cancelAnimationFrame(raf);
        });

        playlist.addEventListener('mousemove', e => {
          if (!dragging) return;
          e.preventDefault();
          const now = Date.now();
          const dy = e.pageY - lastY;
          const dt = now - lastTime;
          if (dt > 0) vel = dy / dt * 16;
          playlist.scrollTop = scrollStart - (e.pageY - startY);
          lastY = e.pageY;
          lastTime = now;
          this.updateScrollArrows();

          if (!dragStarted && Math.abs(e.pageY - startY) > 5) {
            dragStarted = true;
            preventClick = true;
          }
        });

        ['mouseup', 'mouseleave'].forEach(ev => {
          playlist.addEventListener(ev, () => {
            if (!dragging) return;
            dragging = false;
            playlist.classList.remove('dragging');
            
            const momentum = () => {
              if (Math.abs(vel) < 0.5) return;
              playlist.scrollTop -= vel;
              vel *= 0.95;
              raf = requestAnimationFrame(momentum);
              this.updateScrollArrows();
            };
            momentum();

            if (preventClick) {
              setTimeout(() => { preventClick = false; }, 100);
            }
          });
        });

        playlist.addEventListener('click', e => {
          if (preventClick) {
            e.preventDefault();
            e.stopPropagation();
          }
        }, true);
      }

      showMiniInfoBoxes(currentTrack, audioData) {
        this.clearMiniInfoBoxes();

        const visiblePoints = map.queryRenderedFeatures({ layers: ['unclustered-point'] });
        
        visiblePoints.forEach(point => {
          const originalIndex = parseInt(point.properties.originalIndex);
          
          // Find this track in current sorted data
          const currentIndex = audioData.findIndex(track => track.originalIndex === originalIndex);
          if (currentIndex === -1) return;
          
          // Skip the currently playing track - it has the main popup
          if (currentIndex === audioController.currentIndex) return;
          
          const track = audioData[currentIndex];
          if (!track) return;

          const coords = point.geometry.coordinates;
          const pixelCoords = map.project(coords);
          
          const infoBox = document.createElement('div');
          infoBox.className = 'mini-infobox';
          infoBox.dataset.trackIndex = currentIndex; // Store current playlist index
          
          const playIcon = document.createElement('div');
          playIcon.className = 'play-icon';
          
          const title = document.createElement('span');
          title.className = 'mini-infobox-title';
          title.textContent = track.name.replace(/^[^\s]+\s+-\s+/, '');
          
          // Make entire mini box clickable to play audio and show popup
          infoBox.addEventListener('click', (e) => {
            e.stopPropagation();
            mapController.playAudio(currentIndex);
          });
          
          infoBox.appendChild(playIcon);
          infoBox.appendChild(title);
          
          // Auto-size based on content
          document.body.appendChild(infoBox);
          const textWidth = title.scrollWidth;
          infoBox.style.maxWidth = Math.min(Math.max(textWidth + 50, 120), 250) + 'px';
          document.body.removeChild(infoBox);
          
          infoBox.style.left = `${pixelCoords.x + 10}px`;
          infoBox.style.top = `${pixelCoords.y - 20}px`;
          
          map.getContainer().appendChild(infoBox);
          this.miniInfoBoxes.push(infoBox);
        });
      }

      updateMiniInfoBoxPositions() {
        // Update positions of existing mini info boxes to follow their geographic points
        this.miniInfoBoxes.forEach(infoBox => {
          const trackIndex = parseInt(infoBox.dataset.trackIndex);
          const track = mapController.audioData[trackIndex];
          if (track) {
            const coords = [parseFloat(track.lng), parseFloat(track.lat)];
            const pixelCoords = map.project(coords);
            infoBox.style.left = `${pixelCoords.x + 10}px`;
            infoBox.style.top = `${pixelCoords.y - 20}px`;
          }
        });
      }

      clearMiniInfoBoxes() {
        this.miniInfoBoxes.forEach(box => {
          if (box.parentNode) {
            box.parentNode.removeChild(box);
          }
        });
        this.miniInfoBoxes = [];
      }

      showClusterPlaylist(e, leaves) {
        this.hideClusterPlaylist();

        const playlist = document.createElement('div');
        playlist.className = 'cluster-playlist';
        
        leaves.forEach(leaf => {
          const item = document.createElement('div');
          item.className = 'cluster-item';
          
          const playIcon = document.createElement('div');
          playIcon.className = 'play-icon';
          
          const title = document.createElement('span');
          title.className = 'cluster-item-title';
          title.textContent = leaf.properties.name.replace(/^[^\s]+\s+-\s+/, '');
          
          item.appendChild(playIcon);
          item.appendChild(title);
          
          item.addEventListener('click', () => {
            mapController.playAudio(parseInt(leaf.properties.id));
            this.hideClusterPlaylist();
          });
          
          item.addEventListener('mouseleave', () => {
            // Small delay to allow moving between items
            setTimeout(() => {
              if (!playlist.matches(':hover')) {
                this.hideClusterPlaylist();
              }
            }, 100);
          });
          
          playlist.appendChild(item);
        });

        // Position the playlist
        playlist.style.left = `${e.point.x + 10}px`;
        playlist.style.top = `${e.point.y - 10}px`;
        
        // Handle playlist mouse leave
        playlist.addEventListener('mouseleave', () => {
          this.hideClusterPlaylist();
        });
        
        map.getContainer().appendChild(playlist);
        this.clusterPlaylist = playlist;
      }

      hideClusterPlaylist() {
        if (this.clusterPlaylist) {
          this.clusterPlaylist.remove();
          this.clusterPlaylist = null;
        }
      }
    }

    // Map Controller Class
    class MapController {
      constructor() {
        this.audioData = [];
        this.originalAudioData = []; // Keep original order for stable map references
        this.currentPopup = null;
        this.isPositioning = false;
        this.animationTimeout = null;
        this.moveTimeout = null;
        this.setupMap();
      }

      // Helper function to get display mile based on sort mode
      getDisplayMile(track) {
        // Don't display mile if it's a placeholder (starts with ~)
        if (track.mile && track.mile.toString().startsWith('~')) {
          return null;
        }
        
        if (audioController.sortMode === 'sobo' && track.mile && track.mile.toString().trim().toLowerCase() !== 'n/a') {
          const nobobMile = parseFloat(track.mile);
          if (!isNaN(nobobMile)) {
            const soboMile = 2655.8 - nobobMile;
            return soboMile.toFixed(1);
          }
        }
        return track.mile;
      }

      // Helper function to get numeric mile value for sorting (handles ~ placeholders)
      getMileForSorting(track) {
        if (!track.mile || track.mile.toString().trim().toLowerCase() === 'n/a') {
          return null;
        }
        
        const mileStr = track.mile.toString();
        if (mileStr.startsWith('~')) {
          // Placeholder mile - remove ~ and parse
          return parseFloat(mileStr.substring(1));
        }
        
        return parseFloat(mileStr);
      }

      setupMap() {
        mapboxgl.accessToken = CONFIG.MAPBOX_TOKEN;
        
        window.map = new mapboxgl.Map({
          container: 'map',
          style: 'mapbox://styles/thmkly/clyup637d004201ri2tkpaywq',
          center: CONFIG.DEFAULT_CENTER,
          zoom: CONFIG.getDefaultZoom()
        });

        map.on('load', () => {
          // Initialize with default atmospheric conditions
          if (typeof map.setSky === 'function') {
            map.setSky({
              'sky-type': 'atmosphere',
              'sky-atmosphere-sun': [180, 45],
              'sky-atmosphere-sun-intensity': 15
            });
          }
          
          if (typeof map.setFog === 'function') {
            map.setFog({
              'range': [0.5, 10],
              'color': 'white',
              'high-color': '#87CEEB',
              'space-color': '#000033',
              'horizon-blend': 0.1,
              'star-intensity': 0
            });
          }
          
          this.setupMapLayers();
          this.setupMapEvents();
          this.loadAudioData();
        });
      }

      setupMapLayers() {
        map.addSource('audio', {
          type: 'geojson',
          data: { type: 'FeatureCollection', features: [] },
          cluster: true,
          clusterMaxZoom: 14,
          clusterRadius: 45
        });

        map.addLayer({
          id: 'clusters',
          type: 'circle',
          source: 'audio',
          filter: ['has', 'point_count'],
          paint: {
            'circle-color': '#51bbd6',
            'circle-opacity': 0.7,
            'circle-stroke-width': 1,
            'circle-stroke-color': '#197991',
            'circle-stroke-opacity': 0.75,
            'circle-radius': [
              'step',
              ['get', 'point_count'],
              18, 3, 22, 5, 26, 6, 30, 7, 34, 8, 36,
              10, 38, 15, 40, 18, 42, 22, 44, 25, 46,
              30, 48, 35, 50, 40, 52, 50, 54, 100, 56
            ]
          }
        });

        map.addLayer({
          id: 'cluster-count',
          type: 'symbol',
          source: 'audio',
          filter: ['has', 'point_count'],
          layout: {
            'text-field': '{point_count_abbreviated}',
            'text-font': ['Open Sans Semibold', 'Arial Unicode MS Bold'],
            'text-size': 12
          }
        });

        map.addLayer({
          id: 'unclustered-point',
          type: 'circle',
          source: 'audio',
          filter: ['!', ['has', 'point_count']],
          paint: {
            'circle-color': '#5c3a2e',
            'circle-radius': 6,
            'circle-opacity': 0.6,
            'circle-stroke-width': 1,
            'circle-stroke-color': '#fff',
            'circle-stroke-opacity': 0.8
          }
        });
      }

      setupMapEvents() {
        ['clusters', 'unclustered-point'].forEach(layer => {
          map.on('mouseenter', layer, () => map.getCanvas().style.cursor = 'pointer');
          map.on('mouseleave', layer, () => map.getCanvas().style.cursor = '');
        });

        map.on('click', 'clusters', (e) => {
          const features = map.queryRenderedFeatures(e.point, { layers: ['clusters'] });
          if (!features.length) return;
          
          const clusterId = features[0].properties.cluster_id;
          map.getSource('audio').getClusterExpansionZoom(clusterId, (err, zoom) => {
            if (err) return;
            map.getSource('audio').getClusterLeaves(clusterId, 100, 0, (_, leaves) => {
              const bounds = new mapboxgl.LngLatBounds();
              leaves.forEach(leaf => bounds.extend(leaf.geometry.coordinates));
              map.fitBounds(bounds, { 
                padding: { top: 50, bottom: 50, left: this.getLeftPadding(), right: 20 } 
              });
            });
          });
        });

        map.on('click', 'unclustered-point', (e) => {
          const feature = e.features[0];
          if (!feature) return;
          const originalIndex = parseInt(feature.properties.originalIndex);
          
          // Find this track in the current sorted playlist
          const currentIndex = this.audioData.findIndex(track => track.originalIndex === originalIndex);
          if (currentIndex !== -1) {
            this.playAudio(currentIndex);
          }
        });

        map.on('move', () => {
          // Update mini box positions in real-time during movement
          uiController.updateMiniInfoBoxPositions();
        });

        map.on('moveend', () => {
          // Refresh mini boxes when movement is completely finished
          if (!this.isPositioning) {
            const visiblePoints = map.queryRenderedFeatures({ layers: ['unclustered-point'] });
            if (visiblePoints.length > 0 && visiblePoints.length < 50) {
              uiController.showMiniInfoBoxes(null, this.audioData);
            }
          }
        });

        document.addEventListener('fullscreenchange', () => {
          uiController.isFullscreen = !!document.fullscreenElement;
          const btn = document.getElementById('fullscreenBtn');
          btn.textContent = uiController.isFullscreen ? 'Exit Fullscreen' : 'Fullscreen';
          btn.classList.toggle('active', uiController.isFullscreen);
        });
      }

      getLeftPadding() {
        return uiController.playlistExpanded ? 370 : 20;
      }

      loadAudioData() {
        const url = `${CONFIG.GOOGLE_SCRIPT_URL}?nocache=${Date.now()}`;
        console.log('Fetching data from:', url);
        
        fetch(url)
          .then(response => {
            console.log('Response status:', response.status);
            return response.text();
          })
          .then(text => {
            console.log('Raw response length:', text.length);
            try {
              const data = JSON.parse(text);
              console.log('Parsed data length:', data.length);
              
              if (data.error) {
                throw new Error(data.error);
              }
              
              if (data.length === 0) {
                throw new Error('No recordings found');
              }
              
              // Add original index to each track for stable map references
              this.originalAudioData = data.map((track, index) => ({
                ...track,
                originalIndex: index
              }));
              
              // Set up data in fixed geographic order (Canada at top for display)
              this.audioData = this.sortByMileAndDate([...this.originalAudioData], 'nobo');
              this.sortAndUpdatePlaylist();
              this.updateMapData();
              
              showNotification(`Loaded ${data.length} recordings`, 2000);
            } catch (parseError) {
              console.error('JSON Parse Error:', parseError);
              throw new Error(`Invalid JSON response: ${parseError.message}`);
            }
          })
          .catch(e => {
            console.error('Load Error:', e);
            const errorMsg = e.message || 'Unknown error occurred';
            document.getElementById('playlist').innerHTML = `<p class="loading-placeholder">Failed to load recordings: ${errorMsg}</p>`;
            showNotification(`Error: ${errorMsg}`, 5000);
          });
      }

      sortAndUpdatePlaylist() {
        // Remember currently playing track
        const currentlyPlayingTrack = audioController.currentIndex >= 0 ? 
          this.audioData[audioController.currentIndex] : null;
        
        // Check if we need to reorder the playlist
        const needsReordering = audioController.sortMode === 'date' || 
                               (audioController.sortMode !== 'date' && this.isCurrentlyChronological());
        
        if (needsReordering) {
          if (audioController.sortMode === 'date') {
            // STEREO: Reorder playlist chronologically
            this.audioData = this.sortByMileAndDate([...this.originalAudioData], 'date');
          } else {
            // NOBO/SOBO: Restore geographic order
            this.audioData = this.sortByMileAndDate([...this.originalAudioData], 'nobo');
          }
          
          // Update current index to match new order
          if (currentlyPlayingTrack) {
            audioController.currentIndex = this.audioData.findIndex(track => 
              track.originalIndex === currentlyPlayingTrack.originalIndex
            );
          }
        }
        
        // Update playlist display
        this.updatePlaylistOnly();
        
        // Restore the active track highlighting after playlist update
        if (currentlyPlayingTrack) {
          this.updateActiveTrack(audioController.currentIndex);
        }
        
        // Set scroll position based on sort mode
        this.setPlaylistScrollPosition();
        
        // Update popup if one is open to show correct mileage
        if (this.currentPopup && currentlyPlayingTrack) {
          this.refreshPopupMileage(currentlyPlayingTrack);
        }
      }

      // Helper to detect if playlist is currently in chronological order
      isCurrentlyChronological() {
        if (this.audioData.length < 2) return false;
        
        // Check if first few items are in chronological order (indicating STEREO mode was used)
        for (let i = 0; i < Math.min(5, this.audioData.length - 1); i++) {
          const currentTime = parsePacific(this.audioData[i].timestamp).toDate();
          const nextTime = parsePacific(this.audioData[i + 1].timestamp).toDate();
          if (currentTime > nextTime) {
            return false; // Not chronological
          }
        }
        return true; // Appears to be chronological
      }

      sortByMileAndDate(data, mode = 'nobo') {
        if (mode === 'date') {
          // STEREO mode: sort everything by timestamp
          return [...data].sort((a, b) => parsePacific(a.timestamp).toDate() - parsePacific(b.timestamp).toDate());
        }
        
        // For NOBO/SOBO: purely spatial sorting by mile (including ~ placeholders)
        const tracksWithMiles = data.filter(track => {
          const mile = this.getMileForSorting(track);
          return mile !== null && !isNaN(mile);
        });
        
        const tracksWithoutMiles = data.filter(track => {
          const mile = this.getMileForSorting(track);
          return mile === null || isNaN(mile);
        });

        // Sort tracks with miles (including placeholders) by mile number
        // NOBO: ascending (0 → 2655), SOBO: descending (2655 → 0)
        const ascending = mode === 'nobo';
        tracksWithMiles.sort((a, b) => {
          const mileA = this.getMileForSorting(a);
          const mileB = this.getMileForSorting(b);
          if (Math.abs(mileA - mileB) < 0.01) { // Same mile (accounting for decimals)
            // If same mile, sort by timestamp
            return parsePacific(a.timestamp).toDate() - parsePacific(b.timestamp).toDate();
          }
          return ascending ? mileA - mileB : mileB - mileA;
        });

        // For display: reverse the order so Canada appears at top
        // NOBO sorted (0→2655) becomes display (2655→0)
        // SOBO sorted (2655→0) stays as (2655→0)
        if (mode === 'nobo') {
          tracksWithMiles.reverse();
        }

        // Sort tracks without miles by timestamp
        tracksWithoutMiles.sort((a, b) => parsePacific(a.timestamp).toDate() - parsePacific(b.timestamp).toDate());

        // Combine: mile-sorted tracks first, then timestamp-sorted tracks without miles
        return [...tracksWithMiles, ...tracksWithoutMiles];
      }

      updateMapData() {
        const source = map.getSource('audio');
        if (!source) return;
        
        // Use original data for map - points stay static regardless of sort order
        const geojson = {
          type: 'FeatureCollection',
          features: this.originalAudioData.map((track, index) => ({
            type: 'Feature',
            geometry: { 
              type: 'Point', 
              coordinates: [parseFloat(track.lng), parseFloat(track.lat)] 
            },
            properties: { 
              ...track, 
              originalIndex: index, // Use original index for stable reference
              mile: track.mile || 'N/A'
            }
          }))
        };
        
        source.setData(geojson);
      }

      updatePlaylistOnly() {
        const playlist = document.getElementById('playlist');
        playlist.innerHTML = '';
        
        this.audioData.forEach((track, index) => {
          const div = document.createElement('div');
          div.className = 'track';
          div.dataset.id = index;
          
          const trackInfo = document.createElement('div');
          trackInfo.className = 'track-info';
          trackInfo.textContent = track.name.replace(/^[^\s]+\s+-\s+/, '');
          
          const trackMile = document.createElement('div');
          trackMile.className = 'track-mile';
          const displayMile = this.getDisplayMile(track);
          const mile = displayMile !== null && displayMile.toString().trim().toLowerCase() !== 'n/a' ? `mi.${displayMile}` : '';
          trackMile.textContent = mile;
          
          div.appendChild(trackInfo);
          div.appendChild(trackMile);
          
          div.addEventListener('click', (e) => {
            this.playAudio(index);
          });
          
          playlist.appendChild(div);
        });
        
        // Show collapse arrow now that playlist is rendered
        const toggleBtn = document.getElementById('playlistToggle');
        toggleBtn.classList.add('visible');
        
        uiController.updateScrollArrows();
        
        // Force scroll position update on initial load
        if (audioController.currentIndex === -1) {
          setTimeout(() => {
            if (audioController.sortMode === 'sobo') {
              playlist.scrollTop = 0;
            } else if (audioController.sortMode === 'date') {
              playlist.scrollTop = 0;
            } else {
              playlist.scrollTop = playlist.scrollHeight;
            }
          }, 150);
        }
      }

      setPlaylistScrollPosition() {
        const playlist = document.getElementById('playlist');
        
        // Set scroll position based on mode, but only if no track is currently playing
        if (audioController.currentIndex === -1) {
          setTimeout(() => {
            if (audioController.sortMode === 'sobo') {
              // SOBO: Scroll to top (starting at Canada/north)
              playlist.scrollTop = 0;
            } else if (audioController.sortMode === 'date') {
              // STEREO: Scroll to top (starting with earliest recordings)
              playlist.scrollTop = 0;
            } else {
              // NOBO: Scroll to bottom (starting at Mexico/south)
              playlist.scrollTop = playlist.scrollHeight;
            }
          }, 100);
        }
      }

      playAudio(index) {
        console.log('playAudio called with index:', index);
        
        const track = this.audioData[index];
        if (!track) {
          console.error('No track found at index:', index);
          return;
        }

        console.log('Playing track:', track.name, 'Timestamp:', track.timestamp);

        // Stop any runaway animations
        if (this.animationTimeout) {
          clearTimeout(this.animationTimeout);
        }

        this.updateActiveTrack(index);
        const audio = audioController.play(index, this.audioData);
        
        // Clear old mini boxes before positioning
        uiController.clearMiniInfoBoxes();
        
        // Apply atmospheric lighting for this track
        atmosphereController.transitionToTrack(track);
        
        // Add delay before positioning to prevent conflicts
        this.animationTimeout = setTimeout(() => {
          this.positionMapForTrack(track, index);
          this.showPopup([parseFloat(track.lng), parseFloat(track.lat)], track, audio, index);
          
          // Show mini boxes after map positioning is complete
          const duration = this.getMovementDuration(track);
          setTimeout(() => {
            uiController.showMiniInfoBoxes(null, this.audioData);
          }, duration + 300);
        }, 100);
      }

      showTrackPopup(index, autoPlay = true) {
        const track = this.audioData[index];
        if (!track) return;

        const coords = [parseFloat(track.lng), parseFloat(track.lat)];
        
        if (autoPlay) {
          this.playAudio(index);
        } else {
          this.positionMapForTrack(track, index);
          this.showPopup(coords, track, null, index);
        }
      }

      updateActiveTrack(index) {
        document.querySelectorAll('.track').forEach(el => el.classList.remove('active-track'));
        const activeTrack = document.querySelector(`.track[data-id="${index}"]`);
        if (activeTrack) {
          activeTrack.classList.add('active-track');
          // Smoother, slower scroll to center the track
          activeTrack.scrollIntoView({ 
            behavior: 'smooth', 
            block: 'center',
            inline: 'nearest'
          });
        }
      }

      positionMapForTrack(track, index) {
        console.log('positionMapForTrack called for:', track.name);
        
        // Prevent multiple simultaneous map movements
        if (this.isPositioning) {
          console.log('Already positioning, skipping...');
          return;
        }
        this.isPositioning = true;

        const coords = [parseFloat(track.lng), parseFloat(track.lat)];
        
        const resetPositioning = () => {
          this.isPositioning = false;
        };

        // Calculate distance for duration scaling
        const currentCenter = map.getCenter();
        const distance = this.calculateDistance(
          currentCenter.lat, currentCenter.lng,
          coords[1], coords[0]
        );
        
        // Distance-based duration: longer for farther points
        const distanceKm = distance / 1000;
        let duration;
        if (distanceKm < 5) {
          duration = 2200; // Close points: normal speed
        } else if (distanceKm < 50) {
          duration = 2200 + ((distanceKm - 5) / 45) * 1800; // Medium: 2.2-4s
        } else {
          duration = Math.min(5000, 4000 + ((distanceKm - 50) / 100) * 1000); // Far: 4-5s max
        }

        // Smooth easing with pronounced landing deceleration
        const smoothLandingEasing = (t) => {
          if (t < 0.3) {
            // Gentle acceleration (30% of time)
            return 2 * t * t;
          } else if (t < 0.7) {
            // Steady cruise (40% of time)
            const localT = (t - 0.3) / 0.4;
            return 0.18 + 0.64 * localT; // Linear middle section
          } else {
            // Slow landing approach (30% of time)
            const localT = (t - 0.7) / 0.3;
            return 0.82 + 0.18 * (1 - Math.pow(1 - localT, 3));
          }
        };

        // Check if we're in 3D mode
        const is3D = uiController.is3DEnabled;
        const targetZoom = is3D ? CONFIG.ZOOM_3D : CONFIG.ZOOM_2D;

        const flyToOptions = {
          center: coords,
          zoom: targetZoom,
          duration,
          easing: smoothLandingEasing
        };
        
        // Add 3D properties for smoother rainbow arc
        if (is3D) {
          flyToOptions.pitch = 75;
          flyToOptions.bearing = map.getBearing();
          // Higher curve for ultra-smooth rainbow effect in 3D
          flyToOptions.curve = 2.5; // Even higher curve = smoother, more elevated arc
        }
        
        map.flyTo(flyToOptions);
        setTimeout(resetPositioning, duration + 200);
      }

      calculateDistance(lat1, lng1, lat2, lng2) {
        const R = 6371e3;
        const toRad = deg => deg * Math.PI / 180;
        const dLat = toRad(lat2 - lat1);
        const dLng = toRad(lng2 - lng1);
        const a = Math.sin(dLat / 2) ** 2 +
                  Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) * Math.sin(dLng / 2) ** 2;
        return 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)) * R;
      }

      showPopup(coords, track, audio, index) {
        if (this.currentPopup) {
          this.currentPopup.remove();
        }

        const container = document.createElement('div');
        container.style.fontFamily = 'helvetica, sans-serif';
        container.style.padding = '2px';

        const title = document.createElement('h3');
        title.textContent = track.name;
        title.style.margin = '0 0 4px 0';
        container.appendChild(title);

        const timestamp = document.createElement('p');
        timestamp.style.margin = '0';
        timestamp.style.fontSize = '0.9em';
        timestamp.style.color = '#555';
        timestamp.innerHTML = `<strong>${this.formatTimestamp(track.timestamp)}</strong>`;
        container.appendChild(timestamp);

        if (track.mile && track.mile.toString().trim().toLowerCase() !== 'n/a') {
          const displayMile = this.getDisplayMile(track);
          if (displayMile !== null) {
            const mile = document.createElement('p');
            mile.className = 'popup-mile';
            mile.style.margin = '0';
            mile.style.fontSize = '0.9em';
            mile.style.color = '#555';
            mile.innerHTML = `<strong>mi.${displayMile}</strong>`;
            container.appendChild(mile);
          }
        }

        if (track.notes?.trim()) {
          const notes = document.createElement('p');
          notes.style.margin = '4px 0';
          notes.style.fontSize = '0.9em';
          notes.textContent = track.notes;
          container.appendChild(notes);
        }

        const controls = document.createElement('div');
        controls.className = 'popup-controls';
        
        const prevBtn = document.createElement('button');
        prevBtn.className = 'nav-arrow';
        prevBtn.innerHTML = '&laquo;';
        prevBtn.title = 'Previous';
        
        // Disable previous button logic based on mode and history
        if (audioController.playMode === 'random') {
          prevBtn.disabled = audioController.playHistory.length === 0;
        } else {
          prevBtn.disabled = index === 0;
        }
        
        prevBtn.addEventListener('click', () => {
          audioController.playPrevious(this.audioData);
        });
        
        const nextBtn = document.createElement('button');
        nextBtn.className = 'nav-arrow';
        nextBtn.innerHTML = '&raquo;';
        nextBtn.title = 'Next';
        nextBtn.disabled = index === this.audioData.length - 1;
        nextBtn.addEventListener('click', () => {
          audioController.playNext(this.audioData);
        });
        
        controls.appendChild(prevBtn);
        
        if (audio) {
          const audioContainer = document.createElement('div');
          audioContainer.className = 'audio-container';
          audioContainer.id = 'audioContainer';
          
          // Ensure audio controls always render properly
          audio.controls = true;
          audio.autoplay = true;
          audio.style.width = '100%';
          audio.controlsList = 'nodownload';
          audio.oncontextmenu = () => false;
          
          // Force audio element to load controls
          audio.load();
          
          // Fallback: if controls don't appear, try recreating
          setTimeout(() => {
            if (!audio.controls || audio.offsetHeight === 0) {
              console.warn('Audio controls not rendering, attempting fix...');
              audio.controls = true;
              audio.style.display = 'block';
              audio.style.visibility = 'visible';
            }
          }, 100);
          
          audioContainer.appendChild(audio);
          controls.appendChild(audioContainer);
        }
        
        controls.appendChild(nextBtn);
        container.appendChild(controls);

        const popup = new mapboxgl.Popup({ 
          offset: 25,
          closeOnClick: false,
          closeOnMove: false,
          maxWidth: '400px'
        })
          .setLngLat(coords)
          .setDOMContent(container)
          .addTo(map);

        this.currentPopup = popup;
      }

      refreshPopupMileage(track) {
        if (!this.currentPopup) return;
        
        const popupContent = this.currentPopup._content;
        const mileElement = popupContent.querySelector('.popup-mile');
        if (mileElement && track.mile && track.mile.toString().trim().toLowerCase() !== 'n/a') {
          const displayMile = this.getDisplayMile(track);
          mileElement.innerHTML = `<strong>mi.${displayMile}</strong>`;
        }
      }

      formatTimestamp(timestamp) {
        // Enhanced timestamp formatting with proper 24hr display and PST/PDT
        const pacificDate = parsePacific(timestamp);
        const jsDate = pacificDate.toDate();
        
        if (!pacificDate.isValid()) {
          console.warn('Invalid timestamp:', timestamp);
          return String(timestamp || '');
        }
        
        // Format with 24-hour time
        const formatter = new Intl.DateTimeFormat('en-US', {
          timeZone: 'America/Los_Angeles',
          year: 'numeric',
          month: 'short',
          day: '2-digit',
          hour: '2-digit',
          minute: '2-digit',
          hour12: false // Force 24-hour format
        });
        
        // Get the timezone abbreviation (PST/PDT)
        const tzAbbr = isDST(jsDate) ? 'PDT' : 'PST';
        
        return formatter.format(jsDate) + ' ' + tzAbbr;
      }

      resetMap() {
        audioController.stop();
        uiController.clearMiniInfoBoxes();
        if (this.currentPopup) {
          this.currentPopup.remove();
          this.currentPopup = null;
        }
        
        // Disable 3D mode if it's enabled
        if (uiController.is3DEnabled) {
          uiController.is3DEnabled = false;
          const btn = document.getElementById('terrain3dBtn');
          btn.classList.remove('active');
          
          map.setTerrain(null);
          if (map.getSource('mapbox-dem')) {
            map.removeSource('mapbox-dem');
          }
        }
        
        // Reset atmospheric conditions to default
        if (typeof map.setSky === 'function') {
          map.setSky({
            'sky-type': 'atmosphere',
            'sky-atmosphere-sun': [180, 45],
            'sky-atmosphere-sun-intensity': 15
          });
        }
        
        if (typeof map.setFog === 'function') {
          map.setFog({
            'range': [0.5, 10],
            'color': 'white',
            'high-color': '#87CEEB',
            'space-color': '#000033',
            'horizon-blend': 0.1,
            'star-intensity': 0
          });
        }
        
        // Remove any atmospheric overlays
        const overlay = document.getElementById('atmosphere-overlay');
        if (overlay) {
          overlay.remove();
        }
        
        // Reset map style filters
        const mapContainer = document.getElementById('map');
        mapContainer.style.filter = 'none';
        
        map.flyTo({
          center: CONFIG.DEFAULT_CENTER,
          zoom: CONFIG.getDefaultZoom(),
          pitch: 0,
          bearing: 0,
          duration: 2000
        });
        
        document.querySelectorAll('.track').forEach(el => el.classList.remove('active-track'));
        
        showNotification('Map reset to default view', 2000);
      }

      getMovementDuration(track) {
        // Calculate the same duration logic used in positionMapForTrack
        const coords = [parseFloat(track.lng), parseFloat(track.lat)];
        const currentCenter = map.getCenter();
        const distance = this.calculateDistance(
          currentCenter.lat, currentCenter.lng,
          coords[1], coords[0]
        );
        
        const distanceKm = distance / 1000;
        let duration;
        if (distanceKm < 5) {
          duration = 2200;
        } else if (distanceKm < 50) {
          duration = 2200 + ((distanceKm - 5) / 45) * 1800;
        } else {
          duration = Math.min(5000, 4000 + ((distanceKm - 50) / 100) * 1000);
        }
        return duration;
      }
    }

    // Initialize controllers
    const audioController = new AudioController();
    const uiController = new UIController();
    const mapController = new MapController();
    const atmosphereController = new AtmosphereController();

    // Initialize map data update after first load
    setTimeout(() => {
      mapController.updateMapData();
    }, 1000);

  </script>

  <script src="https://storage.ko-fi.com/cdn/scripts/overlay-widget.js"></script>
  <script>
    kofiWidgetOverlay.draw('thmkly', {
      'type': 'floating-chat',
      'floating-chat.donateButton.text': 'Support me',
      'floating-chat.donateButton.background-color': '#ff5f5f',
      'floating-chat.donateButton.text-color': '#fff'
    });
  </script>
  <style>
    .floatingchat-container-wrap {
      left: unset !important;
      right: 16px !important;
      bottom: 30px !important;
    }
    .floating-chat-kofi-popup-iframe {
      left: unset !important;
      right: 16px !important;
      bottom: 30px !important;
    }
  </style>
</body>
</html>
