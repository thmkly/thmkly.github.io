<!DOCTYPE html>

<html>
<head>

<script src="https://unpkg.com/dayjs@1/dayjs.min.js"></script>
<script src="https://unpkg.com/dayjs@1/plugin/utc.js"></script>
<script src="https://unpkg.com/dayjs@1/plugin/timezone.js"></script>
<script>
  dayjs.extend(dayjs_plugin_utc);
  dayjs.extend(dayjs_plugin_timezone);
</script>

  <meta charset="utf-8" />
  <title>A Soundmap of the PCT, Stereo 2023</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link href="https://api.mapbox.com/mapbox-gl-js/v3.8.0/mapbox-gl.css" rel="stylesheet" />
<style>
  body {
    margin: 0;
    padding: 0;
    font-family: helvetica, sans-serif;
  }

  #map {
    position: absolute;
    top: 0;
    bottom: 0;
    width: 100%;
  }

  /* Playlist Styles */
  .playlist-wrapper {
    position: absolute;
    top: 30px;
    left: 10px;
    width: 350px;
    max-height: 90vh;
    border-radius: 5px;
    box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
    background-color: rgba(255, 255, 255, 0.75);
    font-family: helvetica;
    font-size: small;
    display: flex;
    flex-direction: column;
    align-items: stretch;
    z-index: 2;
    transition: transform 0.3s ease;
  }

  .playlist-wrapper.collapsed {
    transform: translateX(-360px);
  }

  .playlist-toggle {
    position: absolute;
    right: -20px;
    top: 50%;
    transform: translateY(-50%);
    width: 20px;
    height: 50px;
    background-color: rgba(255, 255, 255, 0.75);
    border: none;
    border-radius: 0 5px 5px 0;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 12px;
    color: #333;
    box-shadow: 2px 0 5px rgba(0, 0, 0, 0.2);
    z-index: 3;
    transition: background-color 0.2s;
    opacity: 0;
    transition: opacity 0.3s ease, background-color 0.2s;
  }

  .playlist-toggle.visible {
    opacity: 1;
  }

  .playlist-toggle:hover {
    background-color: rgba(255, 255, 255, 0.9);
  }

  .playlist-wrapper:not(.collapsed) .playlist-toggle {
    background-color: transparent;
    box-shadow: none;
  }

  .playlist {
    overflow-y: auto;
    max-height: 85vh;
    padding: 5px;
    cursor: grab;
    user-select: none;
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
  }

  .playlist.dragging {
    cursor: grabbing;
  }

  .scroll-arrow {
    text-align: center;
    font-size: 12px;
    color: black;
    padding: 4px 0;
    user-select: none;
    cursor: pointer;
    display: none;
  }

  .track {
    cursor: pointer;
    padding: 5px;
    margin: 1px;
    border-bottom: 1px solid #ccc;
    display: flex;
    justify-content: space-between;
    align-items: center;
  }

  .track:hover {
    background-color: #f0f0f0;
  }

  .active-track {
    background-color: #d0d0d0;
  }

  .track-info {
    flex: 1;
  }

  .track-mile {
    font-size: 0.8em;
    color: #666;
    min-width: 40px;
    text-align: right;
  }

  /* Control Panel */
  .control-panel {
    position: absolute;
    top: 25px;
    right: 25px;
    background-color: rgba(255, 255, 255, 0.9);
    border-radius: 5px;
    box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
    padding: 10px;
    z-index: 2;
    display: flex;
    flex-direction: column;
    gap: 8px;
  }

  .control-row {
    display: flex;
    gap: 8px;
  }

  .control-btn {
    padding: 6px 12px;
    border: 1px solid #ccc;
    border-radius: 3px;
    background-color: white;
    cursor: pointer;
    font-size: 12px;
    transition: all 0.2s;
  }

  .control-btn:hover {
    background-color: #f0f0f0;
  }

  .control-btn.active {
    background-color: #5c3a2e;
    color: white;
    border-color: #5c3a2e;
  }

  .sort-controls {
    display: flex;
    gap: 4px;
    align-items: center;
  }

  .sort-btn {
    padding: 4px 8px;
    font-size: 11px;
  }

  .random-control {
    display: flex;
    align-items: center;
    gap: 6px;
    margin-left: 8px;
  }

  .random-label {
    font-size: 11px;
    color: #333;
  }

  .toggle-switch {
    position: relative;
    width: 36px;
    height: 18px;
    background-color: #ccc;
    border-radius: 9px;
    cursor: pointer;
    transition: background-color 0.3s;
  }

  .toggle-switch.active {
    background-color: #5c3a2e;
  }

  .toggle-slider {
    position: absolute;
    top: 2px;
    left: 2px;
    width: 14px;
    height: 14px;
    background-color: white;
    border-radius: 50%;
    transition: transform 0.3s;
  }

  .toggle-switch.active .toggle-slider {
    transform: translateX(18px);
  }

  /* Mini Info Boxes */
  .mini-infobox {
    position: absolute;
    background: rgba(255, 255, 255, 0.85);
    border: 1px solid #ccc;
    border-radius: 4px;
    padding: 4px 8px;
    font-size: 11px;
    color: #333;
    pointer-events: auto;
    cursor: pointer;
    z-index: 1;
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
    display: flex;
    align-items: center;
    gap: 4px;
    max-width: 200px;
    white-space: nowrap;
    overflow: visible;
    transition: background-color 0.2s;
  }

  .mini-infobox:hover {
    background: rgba(240, 240, 240, 0.9);
  }

  .mini-infobox-title {
    flex: 1;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
    cursor: pointer;
  }

  .play-icon {
    width: 0;
    height: 0;
    border-left: 6px solid #5c3a2e;
    border-top: 4px solid transparent;
    border-bottom: 4px solid transparent;
    flex-shrink: 0;
    cursor: pointer;
  }

  .play-icon:hover {
    border-left-color: #4a2e24;
  }

  /* Popup Controls */
  .popup-controls {
    display: flex;
    justify-content: space-between;
    align-items: center;
    gap: 10px;
    margin: 8px 0;
    position: relative;
  }

  .nav-arrow {
    background: transparent;
    color: #333;
    border: 1px solid #ccc;
    border-radius: 3px;
    padding: 8px 12px;
    cursor: pointer;
    font-size: 14px;
    font-weight: bold;
    transition: all 0.2s;
    min-width: 40px;
    display: flex;
    align-items: center;
    justify-content: center;
  }

  .nav-arrow:hover {
    background: #f0f0f0;
    color: #000;
  }

  .nav-arrow:disabled {
    background: transparent;
    color: #ccc;
    border-color: #eee;
    cursor: not-allowed;
  }

  .audio-container {
    flex: 1;
    margin: 0 10px;
  }

  /* Cluster Playlist */
  .cluster-playlist {
    position: absolute;
    background: rgba(255, 255, 255, 0.85);
    border: 1px solid #ccc;
    border-radius: 4px;
    padding: 4px;
    font-size: 11px;
    max-width: 250px;
    max-height: 200px;
    overflow-y: auto;
    z-index: 1000;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
  }

  .cluster-item {
    padding: 4px 8px;
    cursor: pointer;
    border-bottom: 1px solid #eee;
    display: flex;
    align-items: center;
    gap: 4px;
    transition: background-color 0.2s;
    border-radius: 2px;
    margin: 1px 0;
  }

  .cluster-item:hover {
    background-color: rgba(240, 240, 240, 0.9);
  }

  .cluster-item:last-child {
    border-bottom: none;
  }

  .cluster-item-title {
    flex: 1;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
  }

  .cluster-item .play-icon {
    width: 0;
    height: 0;
    border-left: 5px solid #5c3a2e;
    border-top: 3px solid transparent;
    border-bottom: 3px solid transparent;
    flex-shrink: 0;
  }

  .cluster-item:hover .play-icon {
    border-left-color: #4a2e24;
  }

  /* Map Controls */
  .mapboxgl-canvas {
    cursor: grab;
  }

  .mapboxgl-popup {
    z-index: 10 !important;
  }

  .mapboxgl-popup-content {
    opacity: 0.8;
    transition: opacity 0.3s ease;
    min-width: 320px;
    max-width: 90vw;
    box-sizing: border-box;
  }

  .mapboxgl-popup-close-button:focus {
    outline: none;
    box-shadow: none;
  }

  .loading-placeholder {
    text-align: center;
    color: #555;
    padding: 8px;
  }

  /* Notification Messages */
  .notification {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: rgba(0, 0, 0, 0.7);
    color: white;
    padding: 12px 20px;
    border-radius: 6px;
    font-size: 14px;
    z-index: 10000;
    pointer-events: none;
    opacity: 0;
    transition: opacity 0.3s ease;
  }

  .notification.show {
    opacity: 1;
  }

  /* Responsive adjustments */
  @media (max-width: 768px) {
    .playlist-wrapper {
      width: 300px;
    }
    
    .control-panel {
      right: 10px;
      top: 10px;
    }
    
    .mini-infobox {
      max-width: 150px;
    }
  }

  /* Fullscreen styles */
  .fullscreen-active {
    position: fixed !important;
    top: 0 !important;
    left: 0 !important;
    width: 100vw !important;
    height: 100vh !important;
    z-index: 9999 !important;
  }

  /* Hide audio focus outline */
  audio:focus {
    outline: none;
  }
</style>

<script>
  // Fixed Pacific timestamp parser for ISO format with proper DST handling
  function parsePacific(ts) {
    if (!ts) return dayjs();
    
    // Handle both ISO format (2023-05-06T16:55:00.000Z) and M/D/YYYY format
    let parsed;
    if (ts.includes('T') && ts.includes('Z')) {
      // ISO format - parse as UTC then convert to Pacific
      parsed = dayjs.utc(ts).tz("America/Los_Angeles");
    } else {
      // M/D/YYYY H:mm:ss format - treat as Pacific local time
      parsed = dayjs(ts, "M/D/YYYY H:mm:ss").tz("America/Los_Angeles", true);
    }
    
    return parsed;
  }

  // Helper to determine if date is in DST
  function isDST(date) {
    const year = date.getFullYear();
    
    // DST starts second Sunday in March
    const march = new Date(year, 2, 1); // March 1st
    const firstSunday = march.getDate() + (7 - march.getDay()) % 7;
    const secondSunday = firstSunday + 7;
    const dstStart = new Date(year, 2, secondSunday, 2, 0, 0); // 2 AM
    
    // DST ends first Sunday in November
    const november = new Date(year, 10, 1); // November 1st
    const firstSundayNov = november.getDate() + (7 - november.getDay()) % 7;
    const dstEnd = new Date(year, 10, firstSundayNov, 2, 0, 0); // 2 AM
    
    return date >= dstStart && date < dstEnd;
  }
</script>

</head>
<body>
  <div id="map"></div>
  
  <div class="playlist-wrapper" id="playlistWrapper">
    <button class="playlist-toggle" id="playlistToggle" title="Collapse playlist">◀</button>
    <div class="scroll-arrow up" id="scrollUp" title="Scroll up">▲</div>
    <div class="playlist" id="playlist">
      <div class="loading-placeholder">loading recordings...</div>
    </div>
    <div class="scroll-arrow down" id="scrollDown" title="Scroll down">▼</div>
  </div>

  <div class="control-panel">
    <div class="control-row">
      <button class="control-btn" id="resetMapBtn" title="Reset view and stop playback">Reset Map</button>
      <button class="control-btn" id="fullscreenBtn" title="Fullscreen on/off">Fullscreen</button>
      <button class="control-btn" id="terrain3dBtn" title="3D terrain on/off">3D Terrain</button>
    </div>
    <div class="sort-controls">
      <button class="control-btn sort-btn active" id="sortNobo" title="Northbound playlist">NOBO →</button>
      <button class="control-btn sort-btn" id="sortSobo" title="Southbound playlist">SOBO ↓</button>
      <button class="control-btn sort-btn" id="sortDate" title="Chronological playlist">STEREO ↻</button>
      <div class="random-control">
        <span class="random-label">Random</span>
        <div class="toggle-switch" id="randomToggle" title="Random on/off">
          <div class="toggle-slider"></div>
        </div>
      </div>
    </div>
  </div>

  <div class="notification" id="notification"></div>

  <script src="https://api.mapbox.com/mapbox-gl-js/v3.8.0/mapbox-gl.js"></script>
  <script>
    // Global error handler to catch and log script errors
    window.addEventListener('error', function(e) {
      console.error('Script error caught:', e.error || e.message, 'at', e.filename, ':', e.lineno);
      return false; // Don't suppress the error
    });
    
    // Global error handler for unhandled promise rejections
    window.addEventListener('unhandledrejection', function(e) {
      console.error('Unhandled promise rejection:', e.reason);
    });
  </script>
  <script>
    // Handle missing config.js gracefully
    if (typeof window.MAPBOX_CONFIG === 'undefined') {
      window.MAPBOX_CONFIG = { token: 'pk.eyJ1IjoidGhta2x5IiwiYSI6ImNseXVyMjhueDA3YTQybW9mcHJrZGJ3YnEifQ.Nv-LsNg5eKIE6SeOVVJpYg' };
    }
  </script>
  <script>
    // Configuration
    const CONFIG = {
      MAPBOX_TOKEN: window.MAPBOX_CONFIG?.token || 'pk.eyJ1IjoidGhta2x5IiwiYSI6ImNseXVyMjhueDA3YTQybW9mcHJrZGJ3YnEifQ.Nv-LsNg5eKIE6SeOVVJpYg',
      GOOGLE_SCRIPT_URL: 'https://script.google.com/macros/s/AKfycbygcwJ8ms4Zpq1BeGM_jQTEuajvoYw-A5-nkoTMZ5FBPfOP2DyORWfDuET2TEhXarfd/exec',
      DEFAULT_CENTER: [-122.50276, 41.31727],
      getDefaultZoom: () => {
        try {
          const screenWidth = window.screen.width;
          const screenHeight = window.screen.height;
          
          // Detect browsers that might report altered screen dimensions
          const isBrave = navigator.brave && navigator.brave.isBrave;
          const isFirefox = navigator.userAgent.toLowerCase().includes('firefox');
          const isTor = navigator.userAgent.toLowerCase().includes('tor');
          
          // Some browsers alter screen dimensions for privacy or have inconsistent reporting
          const hasUnreliableScreenData = isBrave || isTor || 
            (isFirefox && screenWidth === 1366 && screenHeight === 768) || // Firefox often defaults to this
            screenWidth === 1024 || screenHeight === 768; // Common privacy screen sizes
          
          // Calculate diagonal pixel resolution
          const diagonalPixels = Math.sqrt(screenWidth * screenWidth + screenHeight * screenHeight);
          
          if (hasUnreliableScreenData) {
            // Fallback logic for browsers with unreliable screen data
            const viewportWidth = window.innerWidth;
            const viewportHeight = window.innerHeight;
            const viewportDiagonal = Math.sqrt(viewportWidth * viewportWidth + viewportHeight * viewportHeight);
            
            if (viewportDiagonal > 2800) {
              return 4.2;
            } else if (viewportDiagonal > 2000) {
              return 4.95;
            } else if (viewportDiagonal > 1800) {
              return 4.45;
            } else if (viewportDiagonal > 1400) {
              return 4.5;
            } else {
              return 4.8;
            }
          } else {
            // Use reference points for interpolation
            const ref1 = { diagonal: 3037, zoom: 4.4 };
            const ref2 = { diagonal: 2203, zoom: 4.95 };
            
            if (diagonalPixels <= ref2.diagonal) {
              const slope = (ref2.zoom - ref1.zoom) / (ref2.diagonal - ref1.diagonal);
              return Math.min(5.5, ref2.zoom + slope * (ref2.diagonal - diagonalPixels));
            } else if (diagonalPixels >= ref1.diagonal) {
              const slope = (ref2.zoom - ref1.zoom) / (ref2.diagonal - ref1.diagonal);
              return Math.max(4.0, ref1.zoom + slope * (diagonalPixels - ref1.diagonal));
            } else {
              const ratio = (diagonalPixels - ref2.diagonal) / (ref1.diagonal - ref2.diagonal);
              return ref2.zoom + ratio * (ref1.zoom - ref2.zoom);
            }
          }
        } catch (e) {
          console.warn('Error calculating zoom, using default:', e);
          return 4.5; // Safe fallback
        }
      },
      ZOOM_2D: 10,
      ZOOM_3D: 14
    };

    // Notification System
    function showNotification(message, duration = 3000) {
      const notification = document.getElementById('notification');
      notification.textContent = message;
      notification.classList.add('show');
      setTimeout(() => {
        notification.classList.remove('show');
      }, duration);
    }

    // Enhanced Atmospheric Lighting System
    class AtmosphereController {
      constructor() {
        this.currentConditions = null;
        this.transitionInProgress = false;
      }

      // Calculate accurate sun position using proper solar algorithms
      calculateSunPosition(date, lat, lng) {
        try {
          // Parse the Pacific time correctly
          const pacificDate = parsePacific(date);
          const jsDate = pacificDate.toDate();
          
          // Get the actual Pacific time components
          const pacificHour = parseInt(pacificDate.format('H'));
          const pacificMinute = parseInt(pacificDate.format('m'));
          const timeDecimal = pacificHour + pacificMinute / 60;
          
          console.log('Calculating sun position for:', {
            input: date,
            pacificFormatted: pacificDate.format('YYYY-MM-DD HH:mm:ss'),
            pacificTime: pacificDate.format('HH:mm'),
            timeDecimal: timeDecimal.toFixed(2),
            isDST: isDST(jsDate),
            lat, lng
          });
          
          // Julian day calculation for the date
          const year = jsDate.getFullYear();
          const month = jsDate.getMonth() + 1;
          const day = jsDate.getDate();
          
          const jd = this.getJulianDayNumber(year, month, day) + (timeDecimal / 24.0);
          const n = jd - 2451545.0;
          
          // Solar longitude calculations
          const L = (280.460 + 0.9856474 * n) % 360;
          const g = this.toRad((357.528 + 0.9856003 * n) % 360);
          const lambda = this.toRad(L + 1.915 * Math.sin(g) + 0.020 * Math.sin(2 * g));
          
          // Sun's declination
          const delta = Math.asin(Math.sin(this.toRad(23.45)) * Math.sin(lambda));
          
          // Hour angle - use local Pacific time directly
          const hourAngle = this.toRad(15 * (timeDecimal - 12));
          
          // Solar position calculations
          const latRad = this.toRad(lat);
          const sinAltitude = Math.sin(latRad) * Math.sin(delta) + 
                             Math.cos(latRad) * Math.cos(delta) * Math.cos(hourAngle);
          const altitude = this.toDeg(Math.asin(Math.max(-1, Math.min(1, sinAltitude))));
          
          // Azimuth calculation
          const cosAltitude = Math.cos(Math.asin(Math.max(-1, Math.min(1, sinAltitude))));
          const cosAzimuth = (Math.sin(delta) - Math.sin(latRad) * sinAltitude) / 
                            (Math.cos(latRad) * cosAltitude);
          let azimuth = this.toDeg(Math.acos(Math.max(-1, Math.min(1, cosAzimuth))));
          
          // Adjust azimuth for afternoon (when hour angle > 0)
          if (hourAngle > 0) {
            azimuth = 360 - azimuth;
          }
          
          console.log(`Solar calculation: Pacific time: ${timeDecimal.toFixed(2)}h (${pacificHour}:${pacificMinute.toString().padStart(2, '0')}), Altitude: ${altitude.toFixed(1)}°, Azimuth: ${azimuth.toFixed(1)}°`);
          
          return { altitude, azimuth };
        } catch (error) {
          console.error('Error in calculateSunPosition:', error);
          // Return default midday sun position
          return { altitude: 45, azimuth: 180 };
        }
      }
      
      getJulianDayNumber(year, month, day) {
        try {
          // Standard Julian day number calculation
          const a = Math.floor((14 - month) / 12);
          const y = year + 4800 - a;
          const m = month + 12 * a - 3;
          
          return day + Math.floor((153 * m + 2) / 5) + 365 * y + 
                 Math.floor(y / 4) - Math.floor(y / 100) + Math.floor(y / 400) - 32045;
        } catch (error) {
          console.error('Error in getJulianDayNumber:', error);
          return 2451545; // J2000.0 epoch as fallback
        }
      }
      
      getJulianDay(date) {
        // This method is no longer used - replaced by getJulianDayNumber
        return this.getJulianDayNumber(date.getFullYear(), date.getMonth() + 1, date.getDate());
      }

      getElevationEffect(mile) {
        // More accurate PCT elevation profile (in feet)
        let elevation = 2500; // Default
        
        if (mile && !isNaN(parseFloat(mile))) {
          const m = parseFloat(mile);
          // Detailed PCT elevation profile based on actual trail data
          if (m < 50) elevation = 2500;            // Campo to Mount Laguna
          else if (m < 100) elevation = 6000;      // Mount Laguna area
          else if (m < 150) elevation = 1200;      // Anza-Borrego descent
          else if (m < 200) elevation = 4500;      // San Felipe Hills
          else if (m < 250) elevation = 1800;      // Desert floor
          else if (m < 350) elevation = 6500;      // San Jacinto approach
          else if (m < 400) elevation = 8500;      // San Jacinto peaks
          else if (m < 450) elevation = 1200;      // Cabazon area
          else if (m < 550) elevation = 6800;      // San Bernardino Mountains
          else if (m < 650) elevation = 8200;      // Big Bear area
          else if (m < 750) elevation = 2800;      // Mojave Desert
          else if (m < 850) elevation = 9000;      // Southern Sierra
          else if (m < 950) elevation = 11500;     // High Sierra peaks
          else if (m < 1050) elevation = 8500;     // Sierra Nevada
          else if (m < 1150) elevation = 7200;     // Northern Sierra
          else if (m < 1250) elevation = 4500;     // Sierra foothills
          else if (m < 1350) elevation = 6200;     // Northern California mountains
          else if (m < 1450) elevation = 5800;     // Shasta area
          else if (m < 1550) elevation = 4200;     // Northern California
          else if (m < 1650) elevation = 5500;     // Southern Oregon Cascades
          else if (m < 1750) elevation = 4800;     // Central Oregon
          else if (m < 1850) elevation = 6200;     // Mount Hood area
          else if (m < 1950) elevation = 3800;     // Columbia River area
          else if (m < 2050) elevation = 5200;     // Washington Cascades
          else if (m < 2150) elevation = 4600;     // Central Washington
          else if (m < 2250) elevation = 6800;     // North Cascades approach
          else if (m < 2350) elevation = 5400;     // North Cascades
          else if (m < 2450) elevation = 4200;     // Northern Washington
          else if (m < 2550) elevation = 5800;     // Glacier Peak area
          else if (m < 2650) elevation = 4000;     // Canadian border approach
          else elevation = 3800;                   // Canadian border
        }
        
        // Higher elevation = clearer atmosphere, more intense colors
        const effect = 1 + (elevation - 2500) / 10000;
        return Math.min(Math.max(effect, 0.7), 1.8);
      }

      getTimePeriod(altitude) {
        // More precise time period determination
        if (altitude < -18) return 'astronomicalNight';
        if (altitude < -12) return 'astronomicalTwilight';
        if (altitude < -6) return 'nauticalTwilight';  
        if (altitude < -0.833) return 'civilTwilight'; // Actual sunrise/sunset altitude
        if (altitude < 6) return 'sunrise';
        if (altitude < 15) return 'goldenHour';
        if (altitude < 30) return 'morning';
        if (altitude < 60) return 'midday';
        return 'noon';
      }

      getSeason(date, lat) {
        const month = date.getMonth() + 1;
        const day = date.getDate();
        
        // More precise seasonal boundaries
        if ((month === 12 && day >= 21) || month <= 2 || (month === 3 && day < 20)) return 'winter';
        if ((month === 3 && day >= 20) || month <= 5 || (month === 6 && day < 21)) return 'spring';
        if ((month === 6 && day >= 21) || month <= 8 || (month === 9 && day < 23)) return 'summer';
        return 'autumn';
      }

      calculateColors(sunPos, period, season, elevationEffect) {
        const colors = {
          sky: '#87CEEB',
          fog: 'rgba(255, 255, 255, 0.4)',
          ambient: '#ffffff',
          horizon: '#E0F6FF'
        };

        // Enhanced period-based colors with smooth transitions
        const periodColors = {
          astronomicalNight: {
            sky: '#000814',
            fog: 'rgba(8, 15, 30, 0.8)',
            ambient: '#0a1929',
            horizon: '#001122'
          },
          astronomicalTwilight: {
            sky: '#1a237e',
            fog: 'rgba(26, 35, 78, 0.7)',
            ambient: '#283593',
            horizon: '#1a237e'
          },
          nauticalTwilight: {
            sky: '#3949ab',
            fog: 'rgba(57, 73, 171, 0.6)',
            ambient: '#3f51b5',
            horizon: '#303f9f'
          },
          civilTwilight: {
            sky: '#5c6bc0',
            fog: 'rgba(92, 107, 192, 0.5)',
            ambient: '#7986cb',
            horizon: '#9fa8da'
          },
          sunrise: {
            sky: '#ff6b47',
            fog: 'rgba(255, 120, 90, 0.3)',
            ambient: '#ff8a65',
            horizon: '#ffab91'
          },
          goldenHour: {
            sky: '#ffa726',
            fog: 'rgba(255, 193, 100, 0.25)',
            ambient: '#ffb74d',
            horizon: '#ffcc02'
          },
          morning: {
            sky: '#42a5f5',
            fog: 'rgba(150, 200, 255, 0.2)',
            ambient: '#64b5f6',
            horizon: '#90caf9'
          },
          midday: {
            sky: '#1e88e5',
            fog: 'rgba(120, 180, 255, 0.15)',
            ambient: '#42a5f5',
            horizon: '#81c784'
          },
          noon: {
            sky: '#1565c0',
            fog: 'rgba(100, 160, 255, 0.1)',
            ambient: '#1976d2',
            horizon: '#66bb6a'
          }
        };

        // Apply period colors
        Object.assign(colors, periodColors[period] || periodColors.midday);

        // Seasonal color temperature adjustments
        const seasonalAdjustments = {
          winter: { hueShift: -10, saturation: 0.85, brightness: 0.9 },
          spring: { hueShift: 5, saturation: 1.1, brightness: 1.05 },
          summer: { hueShift: 10, saturation: 1.15, brightness: 1.1 },
          autumn: { hueShift: 15, saturation: 1.1, brightness: 0.95 }
        };

        // Apply elevation effect (higher = clearer, more saturated)
        if (elevationEffect > 1.1) {
          const factor = Math.min(elevationEffect, 1.5);
          // High elevation gets more intense, clearer colors
          colors.sky = this.adjustColorIntensity(colors.sky, factor);
        }

        return colors;
      }

      adjustColorIntensity(hexColor, intensity) {
        // Simple color intensity adjustment
        if (!hexColor.startsWith('#')) return hexColor;
        
        try {
          const r = parseInt(hexColor.slice(1, 3), 16);
          const g = parseInt(hexColor.slice(3, 5), 16);
          const b = parseInt(hexColor.slice(5, 7), 16);
          
          // Increase saturation for high elevations
          const factor = Math.min(intensity, 1.3);
          const newR = Math.min(255, Math.round(r * factor));
          const newG = Math.min(255, Math.round(g * factor));
          const newB = Math.min(255, Math.round(b * factor));
          
          return `#${newR.toString(16).padStart(2, '0')}${newG.toString(16).padStart(2, '0')}${newB.toString(16).padStart(2, '0')}`;
        } catch (error) {
          console.warn('Color adjustment error:', error);
          return hexColor;
        }
      }

      calculateFog(sunPos, period, elevationEffect) {
        const baseFog = {
          range: [0.5, 10],
          color: 'white',
          'horizon-blend': 0.1,
          'high-color': '#87CEEB',
          'space-color': '#000033',
          'star-intensity': 0
        };

        // More nuanced fog adjustments based on solar elevation
        const altitude = sunPos.altitude;
        
        if (altitude < -18) { // Deep night
          baseFog.range = [0.2, 6];
          baseFog['horizon-blend'] = 0.02;
          baseFog['star-intensity'] = 1.0;
          baseFog.color = 'rgba(5, 10, 20, 0.9)';
          baseFog['space-color'] = '#000011';
        } else if (altitude < -12) { // Astronomical twilight
          baseFog.range = [0.3, 7];
          baseFog['horizon-blend'] = 0.04;
          baseFog['star-intensity'] = 0.8;
          baseFog.color = 'rgba(20, 30, 50, 0.8)';
          baseFog['space-color'] = '#000822';
        } else if (altitude < -6) { // Nautical twilight
          baseFog.range = [0.4, 8];
          baseFog['horizon-blend'] = 0.06;
          baseFog['star-intensity'] = 0.5;
          baseFog.color = 'rgba(40, 55, 80, 0.7)';
          baseFog['space-color'] = '#001133';
        } else if (altitude < -0.833) { // Civil twilight
          baseFog.range = [0.5, 9];
          baseFog['horizon-blend'] = 0.08;
          baseFog['star-intensity'] = 0.2;
          baseFog.color = 'rgba(70, 85, 120, 0.6)';
          baseFog['space-color'] = '#002244';
        } else if (altitude < 6) { // Sunrise/sunset
          baseFog.range = [0.3, 6];
          baseFog['horizon-blend'] = 0.15;
          baseFog['star-intensity'] = 0;
          baseFog.color = 'rgba(255, 140, 100, 0.4)';
          baseFog['high-color'] = '#ff8a65';
        } else if (altitude < 15) { // Golden hour
          baseFog.range = [0.4, 7];
          baseFog['horizon-blend'] = 0.12;
          baseFog['star-intensity'] = 0;
          baseFog.color = 'rgba(255, 180, 120, 0.3)';
          baseFog['high-color'] = '#ffb74d';
        } else if (altitude < 25) { // Morning
          baseFog.range = [0.6, 10];
          baseFog['horizon-blend'] = 0.1;
          baseFog.color = 'rgba(180, 210, 240, 0.25)';
          baseFog['high-color'] = '#64b5f6';
        } else if (altitude < 45) { // Midday
          baseFog.range = [0.8, 12];
          baseFog['horizon-blend'] = 0.08;
          baseFog.color = 'rgba(160, 190, 230, 0.2)';
          baseFog['high-color'] = '#42a5f5';
        } else { // High noon/zenith
          baseFog.range = [1.0, 15];
          baseFog['horizon-blend'] = 0.05;
          baseFog.color = 'rgba(140, 170, 220, 0.15)';
          baseFog['high-color'] = '#1976d2';
        }
        
        // Elevation adjustment with strict limits
        let adjustedRange0 = baseFog.range[0] * Math.min(elevationEffect, 1.4);
        let adjustedRange1 = baseFog.range[1] * Math.min(elevationEffect * 1.1, 1.25);
        
        // Ensure range values are within Mapbox limits
        adjustedRange0 = Math.max(0.1, Math.min(adjustedRange0, 19));
        adjustedRange1 = Math.max(adjustedRange0 + 0.1, Math.min(adjustedRange1, 20));
        
        baseFog.range = [adjustedRange0, adjustedRange1];

        return baseFog;
      } period, elevationEffect) {
        const baseFog = {
          range: [0.5, 10],
          color: 'white',
          'horizon-blend': 0.1,
          'high-color': '#87CEEB',
          'space-color': '#000033',
          'star-intensity': 0
        };

        // Time-based fog adjustments
        const fogProfiles = {
          astronomicalNight: { 
            range: [0.3, 8], 
            'horizon-blend': 0.02, 
            'star-intensity': 1.0,
            color: 'rgba(8, 15, 30, 0.8)',
            'space-color': '#000011'
          },
          astronomicalTwilight: { 
            range: [0.4, 9], 
            'horizon-blend': 0.04, 
            'star-intensity': 0.7,
            color: 'rgba(26, 35, 78, 0.7)'
          },
          nauticalTwilight: { 
            range: [0.5, 10], 
            'horizon-blend': 0.06, 
            'star-intensity': 0.4,
            color: 'rgba(57, 73, 171, 0.6)'
          },
          civilTwilight: { 
            range: [0.6, 11], 
            'horizon-blend': 0.08, 
            'star-intensity': 0.1,
            color: 'rgba(92, 107, 192, 0.5)'
          },
          sunrise: { 
            range: [0.3, 7], 
            'horizon-blend': 0.15, 
            'star-intensity': 0,
            color: 'rgba(255, 120, 90, 0.3)'
          },
          goldenHour: { 
            range: [0.4, 8], 
            'horizon-blend': 0.12, 
            'star-intensity': 0,
            color: 'rgba(255, 193, 100, 0.25)'
          },
          morning: { 
            range: [0.6, 12], 
            'horizon-blend': 0.1, 
            'star-intensity': 0,
            color: 'rgba(150, 200, 255, 0.2)'
          },
          midday: { 
            range: [0.8, 15], 
            'horizon-blend': 0.08, 
            'star-intensity': 0,
            color: 'rgba(120, 180, 255, 0.15)'
          },
          noon: { 
            range: [1.0, 18], 
            'horizon-blend': 0.05, 
            'star-intensity': 0,
            color: 'rgba(100, 160, 255, 0.1)'
          }
        };

        Object.assign(baseFog, fogProfiles[period] || fogProfiles.midday);
        
        // Elevation adjustment: less fog, clearer view at higher elevations
        // Ensure fog range doesn't exceed Mapbox limits (max 20)
        baseFog.range[0] = Math.min(19, Math.max(0.1, baseFog.range[0] * elevationEffect));
        baseFog.range[1] = Math.min(20, Math.max(baseFog.range[0] + 0.1, baseFog.range[1] * Math.min(elevationEffect * 1.2, 1.8)));

        return baseFog;
      }

      calculateLight(sunPos, period, season) {
        // More accurate lighting based on solar elevation
        const altitude = sunPos.altitude;
        let intensity = Math.max(0.05, Math.min(1.0, (altitude + 25) / 70));
        
        // Fine-tuned intensity based on solar elevation
        if (altitude < -18) intensity = 0.05;      // Deep night
        else if (altitude < -12) intensity = 0.1;  // Astronomical twilight
        else if (altitude < -6) intensity = 0.2;   // Nautical twilight
        else if (altitude < -0.833) intensity = 0.4; // Civil twilight
        else if (altitude < 6) intensity = 0.7;    // Sunrise/sunset
        else if (altitude < 15) intensity = 0.85;  // Golden hour
        else if (altitude < 25) intensity = 0.95;  // Morning
        else if (altitude < 45) intensity = 1.0;   // Midday
        else intensity = 1.0;                      // High noon
        
        // Seasonal intensity adjustments
        const seasonMultiplier = {
          winter: 0.85,
          spring: 0.95,
          summer: 1.05,
          autumn: 0.9
        };
        
        intensity *= seasonMultiplier[season] || 1.0;

        // More accurate color temperature
        const lightColors = {
          night: '#2244aa',
          astronomicalTwilight: '#4466cc',
          nauticalTwilight: '#6688ee',
          civilTwilight: '#88aaff',
          sunrise: '#ffaa44',
          goldenHour: '#ffcc66',
          morning: '#ffffff',
          midday: '#ffffff',
          highNoon: '#ffffff',
          zenith: '#ffffff'
        };

        return {
          anchor: 'viewport',
          color: lightColors[period] || '#ffffff',
          intensity: intensity,
          position: [1.15, sunPos.azimuth, Math.max(5, sunPos.altitude)]
        };
      }

      // Smooth transition when switching tracks
      transitionToTrack(track, duration = 3000) {
        if (this.transitionInProgress) return;
        
        // Start the atmospheric transition
        this.applyAtmosphere(track);
      }

      toRad(deg) {
        return deg * Math.PI / 180;
      }

      toDeg(rad) {
        return rad * 180 / Math.PI;
      }
    }

      // Get atmospheric conditions based on sun position, elevation, and time
      getAtmosphericConditions(track) {
        try {
          const pacificDate = parsePacific(track.timestamp);
          const jsDate = pacificDate.toDate();
          const lat = parseFloat(track.lat) || 0;
          const lng = parseFloat(track.lng) || 0;
          
          console.log('Processing atmospheric conditions for:', {
            track: track.name,
            timestamp: track.timestamp,
            pacificFormatted: pacificDate.format('YYYY-MM-DD HH:mm:ss'),
            coords: [lat, lng]
          });
          
          // Calculate sun position
          const sunPos = this.calculateSunPosition(track.timestamp, lat, lng);
          
          // Get elevation effect
          const elevationEffect = this.getElevationEffect(track.mile);
          
          // Determine time period and season
          const period = this.getTimePeriod(sunPos.altitude);
          const season = this.getSeason(jsDate, lat);
          
          // Calculate atmospheric colors and effects
          const colors = this.calculateColors(sunPos, period, season, elevationEffect);
          
          console.log('Atmospheric conditions determined:', {
            period,
            season,
            sunAltitude: sunPos.altitude.toFixed(1),
            sunAzimuth: sunPos.azimuth.toFixed(1),
            elevation: elevationEffect.toFixed(2)
          });
          
          return {
            sunPosition: sunPos,
            period,
            season,
            elevationEffect,
            colors,
            fogSettings: this.calculateFog(sunPos, period, elevationEffect),
            lightSettings: this.calculateLight(sunPos, period, season)
          };
        } catch (error) {
          console.error('Error in getAtmosphericConditions:', error);
          // Return default conditions
          return {
            sunPosition: { altitude: 45, azimuth: 180 },
            period: 'midday',
            season: 'spring',
            elevationEffect: 1.0,
            colors: { sky: '#87CEEB', fog: 'rgba(255, 255, 255, 0.4)', ambient: '#ffffff', horizon: '#E0F6FF' },
            fogSettings: { range: [0.5, 10], color: 'white', 'horizon-blend': 0.1, 'high-color': '#87CEEB', 'space-color': '#000033', 'star-intensity': 0 },
            lightSettings: { anchor: 'viewport', color: '#ffffff', intensity: 1.0, position: [1.15, 180, 45] }
          };
        }
      }

      applyAtmosphere(track) {
        try {
          if (!map || !track) return;
          
          const newConditions = this.getAtmosphericConditions(track);
          
          console.log('Applying atmosphere for:', track.name, 'Period:', newConditions.period);

          // Use smooth transition if we have previous conditions
          if (this.currentConditions && !this.transitionInProgress) {
            this.transitionAtmosphere(this.currentConditions, newConditions, this.transitionDuration);
          } else {
            // Apply immediately if no previous conditions or transition in progress
            this.applyAtmosphereImmediate(newConditions);
          }
          
          this.currentConditions = newConditions;
          
          // Enhanced notification with time and conditions
          const pacificMoment = parsePacific(track.timestamp);
          const jsDate = pacificMoment.toDate();
          const timeStr = pacificMoment.format('H:mm');
          const timeDesc = newConditions.period.replace(/([A-Z])/g, ' $1').toLowerCase().replace(/astronomical|nautical|civil/, '').trim();
          showNotification(`${timeStr} ${isDST(jsDate) ? 'PDT' : 'PST'} - ${timeDesc}`, 3000);
        } catch (error) {
          console.error('Error in applyAtmosphere:', error);
        }
      }
      
      applyAtmosphereImmediate(conditions) {
        try {
          // Apply Mapbox Sky API
          if (typeof map.setSky === 'function') {
            map.setSky({
              'sky-type': 'atmosphere',
              'sky-atmosphere-sun': [conditions.sunPosition.azimuth, Math.max(0, conditions.sunPosition.altitude)],
              'sky-atmosphere-sun-intensity': this.getSunIntensity(conditions.period, conditions.sunPosition.altitude),
              'sky-atmosphere-color': conditions.colors.sky,
              'sky-gradient': [
                'interpolate',
                ['linear'],
                ['sky-radial-progress'],
                0.8,
                conditions.colors.horizon,
                1,
                conditions.colors.sky
              ],
              'sky-atmosphere-halo-color': this.getHaloColor(conditions.period),
              'sky-opacity': this.getSkyOpacity(conditions.period)
            });
          }

          // Apply Mapbox Fog API
          if (typeof map.setFog === 'function') {
            map.setFog(conditions.fogSettings);
          }

          // Apply lighting for 3D mode
          if (uiController.is3DEnabled && typeof map.setLight === 'function') {
            map.setLight(conditions.lightSettings);
          }

          // Fallback atmospheric effects
          if (typeof map.setSky !== 'function' || typeof map.setFog !== 'function') {
            this.applyFallbackAtmosphere(conditions);
          }
        } catch (error) {
          console.warn('Error applying atmosphere:', error);
        }
      }

      getSunIntensity(period, altitude) {
        const intensityMap = {
          astronomicalNight: 0.1,
          astronomicalTwilight: 0.3,
          nauticalTwilight: 0.5,
          civilTwilight: 1.0,
          sunrise: 8.0,
          goldenHour: 12.0,
          morning: 15.0,
          midday: 18.0,
          noon: 20.0
        };
        return intensityMap[period] || 15.0;
      }

      getHaloColor(period) {
        const haloColors = {
          astronomicalNight: '#001122',
          astronomicalTwilight: '#1a237e',
          nauticalTwilight: '#3949ab',
          civilTwilight: '#5c6bc0',
          sunrise: '#ff8a65',
          goldenHour: '#ffb74d',
          morning: '#81c784',
          midday: '#4fc3f7',
          noon: '#29b6f6'
        };
        return haloColors[period] || '#ffffff';
      }

      getSkyOpacity(period) {
        const opacityMap = {
          astronomicalNight: 0.8,
          astronomicalTwilight: 0.85,
          nauticalTwilight: 0.9,
          civilTwilight: 0.95,
          sunrise: 1.0,
          goldenHour: 1.0,
          morning: 1.0,
          midday: 1.0,
          noon: 1.0
        };
        return opacityMap[period] || 1.0;
      }

      // Enhanced fallback for browsers without full API support
      applyFallbackAtmosphere(conditions) {
        const existingOverlay = document.getElementById('atmosphere-overlay');
        if (existingOverlay) {
          existingOverlay.remove();
        }

        const overlay = document.createElement('div');
        overlay.id = 'atmosphere-overlay';
        overlay.style.cssText = `
          position: absolute;
          top: 0;
          left: 0;
          right: 0;
          bottom: 0;
          pointer-events: none;
          z-index: 1;
          transition: all 2s ease-in-out;
        `;
        
        // Enhanced gradients for different periods
        const overlayEffects = {
          astronomicalNight: 'radial-gradient(ellipse at center, rgba(0, 8, 20, 0.4), rgba(0, 8, 20, 0.7))',
          astronomicalTwilight: 'radial-gradient(ellipse at center, rgba(26, 35, 78, 0.3), rgba(26, 35, 78, 0.6))',
          nauticalTwilight: 'radial-gradient(ellipse at center, rgba(57, 73, 171, 0.25), rgba(57, 73, 171, 0.5))',
          civilTwilight: 'radial-gradient(ellipse at center, rgba(92, 107, 192, 0.2), rgba(92, 107, 192, 0.4))',
          sunrise: 'linear-gradient(to bottom, rgba(255, 107, 71, 0.3) 0%, rgba(255, 138, 101, 0.2) 40%, rgba(255, 171, 145, 0.1) 70%, transparent 100%)',
          goldenHour: 'linear-gradient(to bottom, rgba(255, 167, 38, 0.25) 0%, rgba(255, 183, 77, 0.15) 50%, rgba(255, 204, 2, 0.05) 80%, transparent 100%)',
          morning: 'radial-gradient(ellipse at center, rgba(66, 165, 245, 0.08), rgba(100, 181, 246, 0.03))',
          midday: 'radial-gradient(ellipse at center, transparent, rgba(30, 136, 229, 0.02))',
          noon: 'radial-gradient(ellipse at center, transparent, transparent)'
        };

        overlay.style.background = overlayEffects[conditions.period] || overlayEffects.midday;
        
        // Enhanced filter effects
        const filterEffects = {
          astronomicalNight: 'brightness(0.4) contrast(1.2) saturate(0.7) hue-rotate(-10deg)',
          astronomicalTwilight: 'brightness(0.5) contrast(1.15) saturate(0.8) hue-rotate(-5deg)',
          nauticalTwilight: 'brightness(0.6) contrast(1.1) saturate(0.9)',
          civilTwilight: 'brightness(0.75) contrast(1.05) saturate(0.95)',
          sunrise: 'brightness(1.1) contrast(1.1) saturate(1.3) sepia(0.15) hue-rotate(10deg)',
          goldenHour: 'brightness(1.15) contrast(1.05) saturate(1.2) sepia(0.1) hue-rotate(5deg)',
          morning: 'brightness(1.05) contrast(1.02) saturate(1.1)',
          midday: 'brightness(1.0) contrast(1.0) saturate(1.05)',
          noon: 'brightness(1.05) contrast(1.02) saturate(1.1)'
        };

        const mapContainer = document.getElementById('map');
        mapContainer.style.filter = filterEffects[conditions.period] || filterEffects.midday;
        mapContainer.style.transition = 'filter 2s ease-in-out';
        
        mapContainer.appendChild(overlay);
      }

      toRad(deg) {
        return deg * Math.PI / 180;
      }

      toDeg(rad) {
        return rad * 180 / Math.PI;
      }

      // Smooth transition when switching tracks
      transitionToTrack(track, duration = 2000) {
        if (this.transitionInProgress) return;
        this.transitionInProgress = true;

        // Apply new atmospheric conditions
        this.applyAtmosphere(track);

        setTimeout(() => {
          this.transitionInProgress = false;
        }, duration);
      }
    }

    // Audio Controller Class
    class AudioController {
      constructor() {
        this.currentAudio = null;
        this.currentIndex = -1;
        this.isPlaying = false;
        this.playMode = 'sequential';
        this.sortMode = 'nobo';
        this.playQueue = [];
        this.lastPlayNext = 0;
        this.playHistory = []; // Track play history for random mode
        this.setupWakeLock();
      }

      async setupWakeLock() {
        try {
          if ('wakeLock' in navigator) {
            this.wakeLock = await navigator.wakeLock.request('screen');
          }
        } catch (err) {
          // Wake lock is optional, don't log error
        }
      }

    // Enhanced Atmospheric Lighting System with Smooth Transitions
    class AtmosphereController {
      constructor() {
        this.currentConditions = null;
        this.transitionInProgress = false;
        this.transitionSteps = 20; // Number of steps for smooth transition
        this.transitionDuration = 3000; // 3 seconds for smooth fade
      }

      // More accurate sun position calculation using SPA (Solar Position Algorithm)
      calculateSunPosition(date, lat, lng) {
        try {
          const pacificDate = parsePacific(date);
          const jsDate = pacificDate.toDate();
          
          // Get precise Pacific time
          const pacificHour = parseInt(pacificDate.format('H'));
          const pacificMinute = parseInt(pacificDate.format('m'));
          const pacificSecond = parseInt(pacificDate.format('s'));
          const timeDecimal = pacificHour + pacificMinute / 60 + pacificSecond / 3600;
          
          // More accurate Julian day calculation
          const year = jsDate.getFullYear();
          const month = jsDate.getMonth() + 1;
          const day = jsDate.getDate();
          
          // Calculate day of year
          const dayOfYear = this.getDayOfYear(jsDate);
          
          // Solar declination angle (more accurate)
          const declination = 23.45 * Math.sin(this.toRad(360 * (284 + dayOfYear) / 365.25));
          
          // Equation of time correction
          const B = this.toRad(360 * (dayOfYear - 81) / 365);
          const equationOfTime = 9.87 * Math.sin(2 * B) - 7.53 * Math.cos(B) - 1.5 * Math.sin(B);
          
          // Solar time correction
          const longitudeCorrection = (lng - (-120)) * 4; // Pacific Standard Meridian
          const solarTime = timeDecimal + (equationOfTime + longitudeCorrection) / 60;
          
          // Hour angle
          const hourAngle = 15 * (solarTime - 12);
          
          // Solar elevation angle
          const latRad = this.toRad(lat);
          const decRad = this.toRad(declination);
          const hourAngleRad = this.toRad(hourAngle);
          
          const sinElevation = Math.sin(latRad) * Math.sin(decRad) + 
                              Math.cos(latRad) * Math.cos(decRad) * Math.cos(hourAngleRad);
          const elevation = this.toDeg(Math.asin(Math.max(-1, Math.min(1, sinElevation))));
          
          // Solar azimuth angle
          const cosAzimuth = (Math.sin(decRad) - Math.sin(latRad) * sinElevation) / 
                            (Math.cos(latRad) * Math.cos(Math.asin(Math.max(-1, Math.min(1, sinElevation)))));
          let azimuth = this.toDeg(Math.acos(Math.max(-1, Math.min(1, cosAzimuth))));
          
          // Correct azimuth for time of day
          if (hourAngle > 0) {
            azimuth = 360 - azimuth;
          }
          
          console.log(`Enhanced solar calc: Pacific ${pacificHour}:${pacificMinute.toString().padStart(2, '0')}, Solar time: ${solarTime.toFixed(2)}h, Elevation: ${elevation.toFixed(1)}°, Azimuth: ${azimuth.toFixed(1)}°`);
          
          return { altitude: elevation, azimuth };
        } catch (error) {
          console.error('Error in calculateSunPosition:', error);
          return { altitude: 45, azimuth: 180 };
        }
      }
      
      getDayOfYear(date) {
        const start = new Date(date.getFullYear(), 0, 0);
        const diff = date - start;
        return Math.floor(diff / (1000 * 60 * 60 * 24));
      }
      
      getJulianDayNumber(year, month, day) {
        try {
          const a = Math.floor((14 - month) / 12);
          const y = year + 4800 - a;
          const m = month + 12 * a - 3;
          
          return day + Math.floor((153 * m + 2) / 5) + 365 * y + 
                 Math.floor(y / 4) - Math.floor(y / 100) + Math.floor(y / 400) - 32045;
        } catch (error) {
          console.error('Error in getJulianDayNumber:', error);
          return 2451545;
        }
      }

      // More accurate time period determination
      getTimePeriod(altitude) {
        if (altitude < -18) return 'night';
        if (altitude < -12) return 'astronomicalTwilight';
        if (altitude < -6) return 'nauticalTwilight';  
        if (altitude < -0.833) return 'civilTwilight'; // Actual geometric horizon
        if (altitude < 6) return 'sunrise';
        if (altitude < 15) return 'goldenHour';
        if (altitude < 25) return 'morning';
        if (altitude < 45) return 'midday';
        if (altitude < 60) return 'highNoon';
        return 'zenith';
      }

      // Smooth transition between atmospheric states
      async transitionAtmosphere(fromConditions, toConditions, duration = 3000) {
        if (this.transitionInProgress) return;
        this.transitionInProgress = true;
        
        const steps = this.transitionSteps;
        const stepDuration = duration / steps;
        
        for (let i = 0; i <= steps; i++) {
          const progress = i / steps;
          const easedProgress = this.easeInOutCubic(progress);
          
          // Interpolate between conditions
          const interpolatedConditions = this.interpolateConditions(fromConditions, toConditions, easedProgress);
          
          // Apply interpolated conditions
          this.applyAtmosphereImmediate(interpolatedConditions);
          
          if (i < steps) {
            await new Promise(resolve => setTimeout(resolve, stepDuration));
          }
        }
        
        this.transitionInProgress = false;
      }
      
      easeInOutCubic(t) {
        return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
      }
      
      interpolateConditions(from, to, progress) {
        if (!from) return to;
        
        // Interpolate sun position
        const sunPosition = {
          altitude: this.lerp(from.sunPosition.altitude, to.sunPosition.altitude, progress),
          azimuth: this.lerpAngle(from.sunPosition.azimuth, to.sunPosition.azimuth, progress)
        };
        
        // Interpolate fog settings
        const fogSettings = {
          range: [
            this.lerp(from.fogSettings.range[0], to.fogSettings.range[0], progress),
            this.lerp(from.fogSettings.range[1], to.fogSettings.range[1], progress)
          ],
          'horizon-blend': this.lerp(from.fogSettings['horizon-blend'], to.fogSettings['horizon-blend'], progress),
          'star-intensity': this.lerp(from.fogSettings['star-intensity'], to.fogSettings['star-intensity'], progress),
          color: this.interpolateColor(from.fogSettings.color, to.fogSettings.color, progress),
          'high-color': this.interpolateColor(from.fogSettings['high-color'], to.fogSettings['high-color'], progress),
          'space-color': this.interpolateColor(from.fogSettings['space-color'], to.fogSettings['space-color'], progress)
        };
        
        // Interpolate light settings
        const lightSettings = {
          anchor: 'viewport',
          color: this.interpolateColor(from.lightSettings.color, to.lightSettings.color, progress),
          intensity: this.lerp(from.lightSettings.intensity, to.lightSettings.intensity, progress),
          position: [
            this.lerp(from.lightSettings.position[0], to.lightSettings.position[0], progress),
            this.lerpAngle(from.lightSettings.position[1], to.lightSettings.position[1], progress),
            this.lerp(from.lightSettings.position[2], to.lightSettings.position[2], progress)
          ]
        };
        
        return {
          ...to,
          sunPosition,
          fogSettings,
          lightSettings
        };
      }
      
      lerp(a, b, t) {
        return a + (b - a) * t;
      }
      
      lerpAngle(a, b, t) {
        // Handle angle wrapping (0-360 degrees)
        const diff = ((b - a + 540) % 360) - 180;
        return (a + diff * t + 360) % 360;
      }
      
      interpolateColor(colorA, colorB, t) {
        // Simple color interpolation (works for hex colors and rgba)
        if (!colorA || !colorB) return colorB || colorA || '#ffffff';
        
        // For hex colors
        if (colorA.startsWith('#') && colorB.startsWith('#')) {
          const hexToRgb = (hex) => {
            const r = parseInt(hex.slice(1, 3), 16);
            const g = parseInt(hex.slice(3, 5), 16);
            const b = parseInt(hex.slice(5, 7), 16);
            return [r, g, b];
          };
          
          const rgbA = hexToRgb(colorA);
          const rgbB = hexToRgb(colorB);
          
          const r = Math.round(this.lerp(rgbA[0], rgbB[0], t));
          const g = Math.round(this.lerp(rgbA[1], rgbB[1], t));
          const b = Math.round(this.lerp(rgbA[2], rgbB[2], t));
          
          return `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;
        }
        
        // For rgba colors or fallback
        return t < 0.5 ? colorA : colorB;
      }

      togglePlayPause() {
        if (!this.currentAudio) return;
        
        if (this.currentAudio.paused) {
          this.currentAudio.play();
          this.isPlaying = true;
        } else {
          this.currentAudio.pause();
          this.isPlaying = false;
        }
      }

      playNext(audioData) {
        // Circuit breaker: prevent rapid successive calls
        const now = Date.now();
        if (this.lastPlayNext && (now - this.lastPlayNext) < 1000) {
          console.warn('PlayNext called too quickly, blocking to prevent loop');
          return;
        }
        this.lastPlayNext = now;

        let nextIndex;
        
        if (this.playMode === 'random') {
          nextIndex = Math.floor(Math.random() * audioData.length);
        } else {
          // Navigation based on sort mode:
          if (this.sortMode === 'date') {
            // STEREO: next goes down chronologically (towards newer/higher index)
            nextIndex = this.currentIndex + 1;
            if (nextIndex >= audioData.length) {
              nextIndex = 0; // Wrap to beginning (earliest)
            }
          } else if (this.sortMode === 'sobo') {
            // SOBO: next goes down the list (towards Mexico/higher index)
            nextIndex = this.currentIndex + 1;
            if (nextIndex >= audioData.length) {
              nextIndex = 0; // Wrap to top (Canada)
            }
          } else { // nobo mode
            // NOBO: next goes up the list (towards Canada/lower index)
            nextIndex = this.currentIndex - 1;
            if (nextIndex < 0) {
              nextIndex = audioData.length - 1; // Wrap to bottom (Mexico)
            }
          }
        }
        
        if (nextIndex !== this.currentIndex) {
          mapController.playAudio(nextIndex);
        }
      }

      playPrevious(audioData) {
        let prevIndex;
        
        if (this.playMode === 'random') {
          // In random mode, only go back if there's history
          if (this.playHistory.length === 0) {
            return; // Do nothing if no history
          }
          prevIndex = this.playHistory.pop();
        } else {
          // Navigation based on sort mode:
          if (this.sortMode === 'date') {
            // STEREO: prev goes up chronologically (towards older/lower index)
            prevIndex = this.currentIndex - 1;
            if (prevIndex < 0) {
              prevIndex = audioData.length - 1; // Wrap to end (latest)
            }
          } else if (this.sortMode === 'sobo') {
            // SOBO: prev goes up the list (towards Canada/lower index)
            prevIndex = this.currentIndex - 1;
            if (prevIndex < 0) {
              prevIndex = audioData.length - 1; // Wrap to bottom (Mexico)
            }
          } else { // nobo mode
            // NOBO: prev goes down the list (towards Mexico/higher index)
            prevIndex = this.currentIndex + 1;
            if (prevIndex >= audioData.length) {
              prevIndex = 0; // Wrap to top (Canada)
            }
          }
        }
        
        mapController.playAudio(prevIndex);
      }

      stop() {
        if (this.currentAudio) {
          this.currentAudio.pause();
          this.currentAudio = null;
        }
        this.isPlaying = false;
        this.currentIndex = -1;
      }
    }

    // UI Controller Class
    class UIController {
      constructor() {
        this.playlistExpanded = true;
        this.isFullscreen = false;
        this.is3DEnabled = false;
        this.miniInfoBoxes = [];
        this.clusterPlaylist = null;
        this.setupEventListeners();
      }

      setupEventListeners() {
        // Playlist toggle
        document.getElementById('playlistToggle').addEventListener('click', () => {
          this.togglePlaylist();
        });

        // Sort buttons
        document.querySelectorAll('.sort-btn').forEach(btn => {
          btn.addEventListener('click', (e) => {
            this.handleSortChange(e.target.id);
          });
        });

        // Random toggle
        document.getElementById('randomToggle').addEventListener('click', () => {
          audioController.playMode = audioController.playMode === 'random' ? 'sequential' : 'random';
          this.updateRandomToggle();
        });

        document.getElementById('resetMapBtn').addEventListener('click', () => {
          mapController.resetMap();
        });

        document.getElementById('fullscreenBtn').addEventListener('click', () => {
          this.toggleFullscreen();
        });

        document.getElementById('terrain3dBtn').addEventListener('click', () => {
          this.toggle3D();
        });

        // Global spacebar handler - prevent focus on audio elements
        document.addEventListener('keydown', (e) => {
          if (e.code === 'Space' && audioController.currentAudio) {
            e.preventDefault();
            audioController.togglePlayPause();
            // Blur any focused audio elements
            if (document.activeElement.tagName === 'AUDIO') {
              document.activeElement.blur();
            }
          }
        });

        // Scroll arrows
        const playlist = document.getElementById('playlist');
        const scrollUp = document.getElementById('scrollUp');
        const scrollDown = document.getElementById('scrollDown');

        playlist.addEventListener('scroll', () => this.updateScrollArrows());
        scrollUp.addEventListener('click', () => playlist.scrollBy({ top: -100, behavior: 'smooth' }));
        scrollDown.addEventListener('click', () => playlist.scrollBy({ top: 100, behavior: 'smooth' }));

        this.setupPlaylistDrag();
      }

      togglePlaylist() {
        const wrapper = document.getElementById('playlistWrapper');
        const toggle = document.getElementById('playlistToggle');
        
        this.playlistExpanded = !this.playlistExpanded;
        
        if (this.playlistExpanded) {
          wrapper.classList.remove('collapsed');
          toggle.textContent = '◀';
          toggle.title = 'Collapse playlist';
        } else {
          wrapper.classList.add('collapsed');
          toggle.textContent = '▶';
          toggle.title = 'Expand playlist';
        }
      }

      handleSortChange(sortId) {
        document.querySelectorAll('.sort-btn').forEach(btn => btn.classList.remove('active'));
        document.getElementById(sortId).classList.add('active');

        const sortMap = {
          'sortNobo': 'nobo',
          'sortSobo': 'sobo',
          'sortDate': 'date'
        };
        
        audioController.sortMode = sortMap[sortId];
        mapController.sortAndUpdatePlaylist();
      }

      updateRandomToggle() {
        const toggle = document.getElementById('randomToggle');
        toggle.classList.toggle('active', audioController.playMode === 'random');
      }

      toggleFullscreen() {
        const body = document.body;
        
        if (!this.isFullscreen) {
          if (body.requestFullscreen) {
            body.requestFullscreen();
          } else if (body.webkitRequestFullscreen) {
            body.webkitRequestFullscreen();
          } else if (body.msRequestFullscreen) {
            body.msRequestFullscreen();
          }
        } else {
          if (document.exitFullscreen) {
            document.exitFullscreen();
          } else if (document.webkitExitFullscreen) {
            document.webkitExitFullscreen();
          } else if (document.msExitFullscreen) {
            document.msExitFullscreen();
          }
        }
      }

      toggle3D() {
        this.is3DEnabled = !this.is3DEnabled;
        const btn = document.getElementById('terrain3dBtn');
        btn.classList.toggle('active', this.is3DEnabled);

        if (this.is3DEnabled) {
          // Add 3D terrain source (enhanced for v3)
          if (!map.getSource('mapbox-dem')) {
            map.addSource('mapbox-dem', {
              'type': 'raster-dem',
              'url': 'mapbox://mapbox.mapbox-terrain-dem-v1',
              'tileSize': 512,
              'maxzoom': 14
            });
          }
          
          // Set terrain with v3 optimizations
          map.setTerrain({ 
            'source': 'mapbox-dem', 
            'exaggeration': 1.5 
          });
          
          // Enhanced lighting for 3D in v3
          if (typeof map.setLight === 'function') {
            // Use current atmospheric conditions if available
            if (atmosphereController.currentConditions) {
              map.setLight(atmosphereController.currentConditions.lightSettings);
            } else {
              map.setLight({
                'anchor': 'viewport',
                'color': 'white',
                'intensity': 0.5,
                'position': [1.15, 210, 30]
              });
            }
          }
          
          // Wait for terrain to be ready, then apply 3D positioning
          const apply3DView = () => {
            if (audioController.currentIndex >= 0) {
              const currentTrack = mapController.audioData[audioController.currentIndex];
              if (currentTrack) {
                // Position for 3D view of current track
                const coords = [parseFloat(currentTrack.lng), parseFloat(currentTrack.lat)];
                map.flyTo({
                  center: coords,
                  zoom: CONFIG.ZOOM_3D,
                  pitch: 75,
                  bearing: 0,
                  duration: 2500,
                  easing: t => 1 - Math.pow(1 - t, 3)
                });
                
                // Apply atmospheric lighting for current track
                atmosphereController.applyAtmosphere(currentTrack);
              } else {
                // No valid track, just enable 3D at current location
                map.flyTo({
                  pitch: 75,
                  zoom: Math.max(map.getZoom(), CONFIG.ZOOM_3D),
                  duration: 2000
                });
              }
            } else {
              // No active track, just enable 3D at current location
              map.flyTo({
                pitch: 75,
                zoom: Math.max(map.getZoom(), CONFIG.ZOOM_3D),
                duration: 2000
              });
            }
            showNotification('3D view enabled - Hold Ctrl + drag to rotate', 4000);
          };
          
          // Wait a moment for terrain to initialize, then apply 3D view
          setTimeout(apply3DView, 300);
          
        } else {
          // Disable 3D
          map.setTerrain(null);
          if (typeof map.setLight === 'function') {
            map.setLight(null); // Reset lighting
          }
          map.flyTo({
            pitch: 0,
            duration: 1500
          });
          
          // Clean up terrain source
          setTimeout(() => {
            if (map.getSource('mapbox-dem')) {
              map.removeSource('mapbox-dem');
            }
          }, 1600);
          
          showNotification('3D view disabled', 2000);
        }
      }

      updateScrollArrows() {
        const playlist = document.getElementById('playlist');
        const scrollUp = document.getElementById('scrollUp');
        const scrollDown = document.getElementById('scrollDown');
        
        scrollUp.style.display = playlist.scrollTop > 0 ? 'block' : 'none';
        scrollDown.style.display = (playlist.scrollTop + playlist.clientHeight) < playlist.scrollHeight ? 'block' : 'none';
      }

      setupPlaylistDrag() {
        const playlist = document.getElementById('playlist');
        let dragging = false, startY, scrollStart, vel = 0, lastY = 0, lastTime = 0, raf;
        let dragStarted = false, preventClick = false;

        playlist.addEventListener('mousedown', e => {
          dragging = true;
          dragStarted = false;
          playlist.classList.add('dragging');
          startY = e.pageY;
          scrollStart = playlist.scrollTop;
          vel = 0;
          lastY = e.pageY;
          lastTime = Date.now();
          if (raf) cancelAnimationFrame(raf);
        });

        playlist.addEventListener('mousemove', e => {
          if (!dragging) return;
          e.preventDefault();
          const now = Date.now();
          const dy = e.pageY - lastY;
          const dt = now - lastTime;
          if (dt > 0) vel = dy / dt * 16;
          playlist.scrollTop = scrollStart - (e.pageY - startY);
          lastY = e.pageY;
          lastTime = now;
          this.updateScrollArrows();

          if (!dragStarted && Math.abs(e.pageY - startY) > 5) {
            dragStarted = true;
            preventClick = true;
          }
        });

        ['mouseup', 'mouseleave'].forEach(ev => {
          playlist.addEventListener(ev, () => {
            if (!dragging) return;
            dragging = false;
            playlist.classList.remove('dragging');
            
            const momentum = () => {
              if (Math.abs(vel) < 0.5) return;
              playlist.scrollTop -= vel;
              vel *= 0.95;
              raf = requestAnimationFrame(momentum);
              this.updateScrollArrows();
            };
            momentum();

            if (preventClick) {
              setTimeout(() => { preventClick = false; }, 100);
            }
          });
        });

        playlist.addEventListener('click', e => {
          if (preventClick) {
            e.preventDefault();
            e.stopPropagation();
          }
        }, true);
      }

      showMiniInfoBoxes(currentTrack, audioData) {
        this.clearMiniInfoBoxes();

        const visiblePoints = map.queryRenderedFeatures({ layers: ['unclustered-point'] });
        
        visiblePoints.forEach(point => {
          const originalIndex = parseInt(point.properties.originalIndex);
          
          // Find this track in current sorted data
          const currentIndex = audioData.findIndex(track => track.originalIndex === originalIndex);
          if (currentIndex === -1) return;
          
          // Skip the currently playing track - it has the main popup
          if (currentIndex === audioController.currentIndex) return;
          
          const track = audioData[currentIndex];
          if (!track) return;

          const coords = point.geometry.coordinates;
          const pixelCoords = map.project(coords);
          
          const infoBox = document.createElement('div');
          infoBox.className = 'mini-infobox';
          infoBox.dataset.trackIndex = currentIndex; // Store current playlist index
          
          const playIcon = document.createElement('div');
          playIcon.className = 'play-icon';
          
          const title = document.createElement('span');
          title.className = 'mini-infobox-title';
          title.textContent = track.name.replace(/^[^\s]+\s+-\s+/, '');
          
          // Make entire mini box clickable to play audio and show popup
          infoBox.addEventListener('click', (e) => {
            e.stopPropagation();
            mapController.playAudio(currentIndex);
          });
          
          infoBox.appendChild(playIcon);
          infoBox.appendChild(title);
          
          // Auto-size based on content
          document.body.appendChild(infoBox);
          const textWidth = title.scrollWidth;
          infoBox.style.maxWidth = Math.min(Math.max(textWidth + 50, 120), 250) + 'px';
          document.body.removeChild(infoBox);
          
          infoBox.style.left = `${pixelCoords.x + 10}px`;
          infoBox.style.top = `${pixelCoords.y - 20}px`;
          
          map.getContainer().appendChild(infoBox);
          this.miniInfoBoxes.push(infoBox);
        });
      }

      updateMiniInfoBoxPositions() {
        // Update positions of existing mini info boxes to follow their geographic points
        this.miniInfoBoxes.forEach(infoBox => {
          const trackIndex = parseInt(infoBox.dataset.trackIndex);
          const track = mapController.audioData[trackIndex];
          if (track) {
            const coords = [parseFloat(track.lng), parseFloat(track.lat)];
            const pixelCoords = map.project(coords);
            infoBox.style.left = `${pixelCoords.x + 10}px`;
            infoBox.style.top = `${pixelCoords.y - 20}px`;
          }
        });
      }

      clearMiniInfoBoxes() {
        this.miniInfoBoxes.forEach(box => {
          if (box.parentNode) {
            box.parentNode.removeChild(box);
          }
        });
        this.miniInfoBoxes = [];
      }

      showClusterPlaylist(e, leaves) {
        this.hideClusterPlaylist();

        const playlist = document.createElement('div');
        playlist.className = 'cluster-playlist';
        
        leaves.forEach(leaf => {
          const item = document.createElement('div');
          item.className = 'cluster-item';
          
          const playIcon = document.createElement('div');
          playIcon.className = 'play-icon';
          
          const title = document.createElement('span');
          title.className = 'cluster-item-title';
          title.textContent = leaf.properties.name.replace(/^[^\s]+\s+-\s+/, '');
          
          item.appendChild(playIcon);
          item.appendChild(title);
          
          item.addEventListener('click', () => {
            mapController.playAudio(parseInt(leaf.properties.id));
            this.hideClusterPlaylist();
          });
          
          item.addEventListener('mouseleave', () => {
            // Small delay to allow moving between items
            setTimeout(() => {
              if (!playlist.matches(':hover')) {
                this.hideClusterPlaylist();
              }
            }, 100);
          });
          
          playlist.appendChild(item);
        });

        // Position the playlist
        playlist.style.left = `${e.point.x + 10}px`;
        playlist.style.top = `${e.point.y - 10}px`;
        
        // Handle playlist mouse leave
        playlist.addEventListener('mouseleave', () => {
          this.hideClusterPlaylist();
        });
        
        map.getContainer().appendChild(playlist);
        this.clusterPlaylist = playlist;
      }

      hideClusterPlaylist() {
        if (this.clusterPlaylist) {
          this.clusterPlaylist.remove();
          this.clusterPlaylist = null;
        }
      }
    }

    // Map Controller Class
    class MapController {
      constructor() {
        this.audioData = [];
        this.originalAudioData = []; // Keep original order for stable map references
        this.currentPopup = null;
        this.isPositioning = false;
        this.animationTimeout = null;
        this.moveTimeout = null;
        this.setupMap();
      }

      // Helper function to get display mile based on sort mode
      getDisplayMile(track) {
        // Don't display mile if it's a placeholder (starts with ~)
        if (track.mile && track.mile.toString().startsWith('~')) {
          return null;
        }
        
        if (audioController.sortMode === 'sobo' && track.mile && track.mile.toString().trim().toLowerCase() !== 'n/a') {
          const nobobMile = parseFloat(track.mile);
          if (!isNaN(nobobMile)) {
            const soboMile = 2655.8 - nobobMile;
            return soboMile.toFixed(1);
          }
        }
        return track.mile;
      }

      // Helper function to get numeric mile value for sorting (handles ~ placeholders)
      getMileForSorting(track) {
        if (!track.mile || track.mile.toString().trim().toLowerCase() === 'n/a') {
          return null;
        }
        
        const mileStr = track.mile.toString();
        if (mileStr.startsWith('~')) {
          // Placeholder mile - remove ~ and parse
          return parseFloat(mileStr.substring(1));
        }
        
        return parseFloat(mileStr);
      }

      setupMap() {
        mapboxgl.accessToken = CONFIG.MAPBOX_TOKEN;
        
        window.map = new mapboxgl.Map({
          container: 'map',
          style: 'mapbox://styles/thmkly/clyup637d004201ri2tkpaywq',
          center: CONFIG.DEFAULT_CENTER,
          zoom: CONFIG.getDefaultZoom()
        });

        map.on('load', () => {
          // Initialize with default atmospheric conditions
          if (typeof map.setSky === 'function') {
            map.setSky({
              'sky-type': 'atmosphere',
              'sky-atmosphere-sun': [180, 45],
              'sky-atmosphere-sun-intensity': 15
            });
          }
          
          if (typeof map.setFog === 'function') {
            map.setFog({
              'range': [0.5, 10],
              'color': 'white',
              'high-color': '#87CEEB',
              'space-color': '#000033',
              'horizon-blend': 0.1,
              'star-intensity': 0
            });
          }
          
          this.setupMapLayers();
          this.setupMapEvents();
          this.loadAudioData();
        });
      }

      setupMapLayers() {
        map.addSource('audio', {
          type: 'geojson',
          data: { type: 'FeatureCollection', features: [] },
          cluster: true,
          clusterMaxZoom: 14,
          clusterRadius: 45
        });

        map.addLayer({
          id: 'clusters',
          type: 'circle',
          source: 'audio',
          filter: ['has', 'point_count'],
          paint: {
            'circle-color': '#51bbd6',
            'circle-opacity': 0.7,
            'circle-stroke-width': 1,
            'circle-stroke-color': '#197991',
            'circle-stroke-opacity': 0.75,
            'circle-radius': [
              'step',
              ['get', 'point_count'],
              18, 3, 22, 5, 26, 6, 30, 7, 34, 8, 36,
              10, 38, 15, 40, 18, 42, 22, 44, 25, 46,
              30, 48, 35, 50, 40, 52, 50, 54, 100, 56
            ]
          }
        });

        map.addLayer({
          id: 'cluster-count',
          type: 'symbol',
          source: 'audio',
          filter: ['has', 'point_count'],
          layout: {
            'text-field': '{point_count_abbreviated}',
            'text-font': ['Open Sans Semibold', 'Arial Unicode MS Bold'],
            'text-size': 12
          }
        });

        map.addLayer({
          id: 'unclustered-point',
          type: 'circle',
          source: 'audio',
          filter: ['!', ['has', 'point_count']],
          paint: {
            'circle-color': '#5c3a2e',
            'circle-radius': 6,
            'circle-opacity': 0.6,
            'circle-stroke-width': 1,
            'circle-stroke-color': '#fff',
            'circle-stroke-opacity': 0.8
          }
        });
      }

      setupMapEvents() {
        ['clusters', 'unclustered-point'].forEach(layer => {
          map.on('mouseenter', layer, () => map.getCanvas().style.cursor = 'pointer');
          map.on('mouseleave', layer, () => map.getCanvas().style.cursor = '');
        });

        map.on('click', 'clusters', (e) => {
          const features = map.queryRenderedFeatures(e.point, { layers: ['clusters'] });
          if (!features.length) return;
          
          const clusterId = features[0].properties.cluster_id;
          map.getSource('audio').getClusterExpansionZoom(clusterId, (err, zoom) => {
            if (err) return;
            map.getSource('audio').getClusterLeaves(clusterId, 100, 0, (_, leaves) => {
              const bounds = new mapboxgl.LngLatBounds();
              leaves.forEach(leaf => bounds.extend(leaf.geometry.coordinates));
              map.fitBounds(bounds, { 
                padding: { top: 50, bottom: 50, left: this.getLeftPadding(), right: 20 } 
              });
            });
          });
        });

        map.on('click', 'unclustered-point', (e) => {
          const feature = e.features[0];
          if (!feature) return;
          const originalIndex = parseInt(feature.properties.originalIndex);
          
          // Find this track in the current sorted playlist
          const currentIndex = this.audioData.findIndex(track => track.originalIndex === originalIndex);
          if (currentIndex !== -1) {
            this.playAudio(currentIndex);
          }
        });

        map.on('move', () => {
          // Update mini box positions in real-time during movement
          uiController.updateMiniInfoBoxPositions();
        });

        map.on('moveend', () => {
          // Refresh mini boxes when movement is completely finished
          if (!this.isPositioning) {
            const visiblePoints = map.queryRenderedFeatures({ layers: ['unclustered-point'] });
            if (visiblePoints.length > 0 && visiblePoints.length < 50) {
              uiController.showMiniInfoBoxes(null, this.audioData);
            }
          }
        });

        document.addEventListener('fullscreenchange', () => {
          uiController.isFullscreen = !!document.fullscreenElement;
          const btn = document.getElementById('fullscreenBtn');
          btn.textContent = uiController.isFullscreen ? 'Exit Fullscreen' : 'Fullscreen';
          btn.classList.toggle('active', uiController.isFullscreen);
        });
      }

      getLeftPadding() {
        return uiController.playlistExpanded ? 370 : 20;
      }

      loadAudioData() {
        const url = `${CONFIG.GOOGLE_SCRIPT_URL}?nocache=${Date.now()}`;
        console.log('Fetching data from:', url);
        
        fetch(url)
          .then(response => {
            console.log('Response status:', response.status);
            return response.text();
          })
          .then(text => {
            console.log('Raw response length:', text.length);
            try {
              const data = JSON.parse(text);
              console.log('Parsed data length:', data.length);
              
              if (data.error) {
                throw new Error(data.error);
              }
              
              if (data.length === 0) {
                throw new Error('No recordings found');
              }
              
              // Add original index to each track for stable map references
              this.originalAudioData = data.map((track, index) => ({
                ...track,
                originalIndex: index
              }));
              
              // Set up data in fixed geographic order (Canada at top for display)
              this.audioData = this.sortByMileAndDate([...this.originalAudioData], 'nobo');
              this.sortAndUpdatePlaylist();
              this.updateMapData();
              
              showNotification(`Loaded ${data.length} recordings`, 2000);
            } catch (parseError) {
              console.error('JSON Parse Error:', parseError);
              throw new Error(`Invalid JSON response: ${parseError.message}`);
            }
          })
          .catch(e => {
            console.error('Load Error:', e);
            const errorMsg = e.message || 'Unknown error occurred';
            document.getElementById('playlist').innerHTML = `<p class="loading-placeholder">Failed to load recordings: ${errorMsg}</p>`;
            showNotification(`Error: ${errorMsg}`, 5000);
          });
      }

      sortAndUpdatePlaylist() {
        // Remember currently playing track
        const currentlyPlayingTrack = audioController.currentIndex >= 0 ? 
          this.audioData[audioController.currentIndex] : null;
        
        // Check if we need to reorder the playlist
        const needsReordering = audioController.sortMode === 'date' || 
                               (audioController.sortMode !== 'date' && this.isCurrentlyChronological());
        
        if (needsReordering) {
          if (audioController.sortMode === 'date') {
            // STEREO: Reorder playlist chronologically
            this.audioData = this.sortByMileAndDate([...this.originalAudioData], 'date');
          } else {
            // NOBO/SOBO: Restore geographic order
            this.audioData = this.sortByMileAndDate([...this.originalAudioData], 'nobo');
          }
          
          // Update current index to match new order
          if (currentlyPlayingTrack) {
            audioController.currentIndex = this.audioData.findIndex(track => 
              track.originalIndex === currentlyPlayingTrack.originalIndex
            );
          }
        }
        
        // Update playlist display
        this.updatePlaylistOnly();
        
        // Restore the active track highlighting after playlist update
        if (currentlyPlayingTrack) {
          this.updateActiveTrack(audioController.currentIndex);
        }
        
        // Set scroll position based on sort mode
        this.setPlaylistScrollPosition();
        
        // Update popup if one is open to show correct mileage
        if (this.currentPopup && currentlyPlayingTrack) {
          this.refreshPopupMileage(currentlyPlayingTrack);
        }
      }

      // Helper to detect if playlist is currently in chronological order
      isCurrentlyChronological() {
        if (this.audioData.length < 2) return false;
        
        // Check if first few items are in chronological order (indicating STEREO mode was used)
        for (let i = 0; i < Math.min(5, this.audioData.length - 1); i++) {
          const currentTime = parsePacific(this.audioData[i].timestamp).toDate();
          const nextTime = parsePacific(this.audioData[i + 1].timestamp).toDate();
          if (currentTime > nextTime) {
            return false; // Not chronological
          }
        }
        return true; // Appears to be chronological
      }

      sortByMileAndDate(data, mode = 'nobo') {
        if (mode === 'date') {
          // STEREO mode: sort everything by timestamp
          return [...data].sort((a, b) => parsePacific(a.timestamp).toDate() - parsePacific(b.timestamp).toDate());
        }
        
        // For NOBO/SOBO: purely spatial sorting by mile (including ~ placeholders)
        const tracksWithMiles = data.filter(track => {
          const mile = this.getMileForSorting(track);
          return mile !== null && !isNaN(mile);
        });
        
        const tracksWithoutMiles = data.filter(track => {
          const mile = this.getMileForSorting(track);
          return mile === null || isNaN(mile);
        });

        // Sort tracks with miles (including placeholders) by mile number
        // NOBO: ascending (0 → 2655), SOBO: descending (2655 → 0)
        const ascending = mode === 'nobo';
        tracksWithMiles.sort((a, b) => {
          const mileA = this.getMileForSorting(a);
          const mileB = this.getMileForSorting(b);
          if (Math.abs(mileA - mileB) < 0.01) { // Same mile (accounting for decimals)
            // If same mile, sort by timestamp
            return parsePacific(a.timestamp).toDate() - parsePacific(b.timestamp).toDate();
          }
          return ascending ? mileA - mileB : mileB - mileA;
        });

        // For display: reverse the order so Canada appears at top
        // NOBO sorted (0→2655) becomes display (2655→0)
        // SOBO sorted (2655→0) stays as (2655→0)
        if (mode === 'nobo') {
          tracksWithMiles.reverse();
        }

        // Sort tracks without miles by timestamp
        tracksWithoutMiles.sort((a, b) => parsePacific(a.timestamp).toDate() - parsePacific(b.timestamp).toDate());

        // Combine: mile-sorted tracks first, then timestamp-sorted tracks without miles
        return [...tracksWithMiles, ...tracksWithoutMiles];
      }

      updateMapData() {
        const source = map.getSource('audio');
        if (!source) return;
        
        // Use original data for map - points stay static regardless of sort order
        const geojson = {
          type: 'FeatureCollection',
          features: this.originalAudioData.map((track, index) => ({
            type: 'Feature',
            geometry: { 
              type: 'Point', 
              coordinates: [parseFloat(track.lng), parseFloat(track.lat)] 
            },
            properties: { 
              ...track, 
              originalIndex: index, // Use original index for stable reference
              mile: track.mile || 'N/A'
            }
          }))
        };
        
        source.setData(geojson);
      }

      updatePlaylistOnly() {
        const playlist = document.getElementById('playlist');
        playlist.innerHTML = '';
        
        this.audioData.forEach((track, index) => {
          const div = document.createElement('div');
          div.className = 'track';
          div.dataset.id = index;
          
          const trackInfo = document.createElement('div');
          trackInfo.className = 'track-info';
          trackInfo.textContent = track.name.replace(/^[^\s]+\s+-\s+/, '');
          
          const trackMile = document.createElement('div');
          trackMile.className = 'track-mile';
          const displayMile = this.getDisplayMile(track);
          const mile = displayMile !== null && displayMile.toString().trim().toLowerCase() !== 'n/a' ? `mi.${displayMile}` : '';
          trackMile.textContent = mile;
          
          div.appendChild(trackInfo);
          div.appendChild(trackMile);
          
          div.addEventListener('click', (e) => {
            this.playAudio(index);
          });
          
          playlist.appendChild(div);
        });
        
        // Show collapse arrow now that playlist is rendered
        const toggleBtn = document.getElementById('playlistToggle');
        toggleBtn.classList.add('visible');
        
        uiController.updateScrollArrows();
        
        // Force scroll position update on initial load
        if (audioController.currentIndex === -1) {
          setTimeout(() => {
            if (audioController.sortMode === 'sobo') {
              playlist.scrollTop = 0;
            } else if (audioController.sortMode === 'date') {
              playlist.scrollTop = 0;
            } else {
              playlist.scrollTop = playlist.scrollHeight;
            }
          }, 150);
        }
      }

      setPlaylistScrollPosition() {
        const playlist = document.getElementById('playlist');
        
        // Set scroll position based on mode, but only if no track is currently playing
        if (audioController.currentIndex === -1) {
          setTimeout(() => {
            if (audioController.sortMode === 'sobo') {
              // SOBO: Scroll to top (starting at Canada/north)
              playlist.scrollTop = 0;
            } else if (audioController.sortMode === 'date') {
              // STEREO: Scroll to top (starting with earliest recordings)
              playlist.scrollTop = 0;
            } else {
              // NOBO: Scroll to bottom (starting at Mexico/south)
              playlist.scrollTop = playlist.scrollHeight;
            }
          }, 100);
        }
      }

      playAudio(index) {
        console.log('playAudio called with index:', index);
        
        const track = this.audioData[index];
        if (!track) {
          console.error('No track found at index:', index);
          return;
        }

        console.log('Playing track:', track.name, 'Timestamp:', track.timestamp);

        // Stop any runaway animations
        if (this.animationTimeout) {
          clearTimeout(this.animationTimeout);
        }

        this.updateActiveTrack(index);
        const audio = audioController.play(index, this.audioData);
        
        // Clear old mini boxes before positioning
        uiController.clearMiniInfoBoxes();
        
        // Apply atmospheric lighting for this track
        atmosphereController.transitionToTrack(track);
        
        // Add delay before positioning to prevent conflicts
        this.animationTimeout = setTimeout(() => {
          this.positionMapForTrack(track, index);
          this.showPopup([parseFloat(track.lng), parseFloat(track.lat)], track, audio, index);
          
          // Show mini boxes after map positioning is complete
          const duration = this.getMovementDuration(track);
          setTimeout(() => {
            uiController.showMiniInfoBoxes(null, this.audioData);
          }, duration + 300);
        }, 100);
      }

      showTrackPopup(index, autoPlay = true) {
        const track = this.audioData[index];
        if (!track) return;

        const coords = [parseFloat(track.lng), parseFloat(track.lat)];
        
        if (autoPlay) {
          this.playAudio(index);
        } else {
          this.positionMapForTrack(track, index);
          this.showPopup(coords, track, null, index);
        }
      }

      updateActiveTrack(index) {
        document.querySelectorAll('.track').forEach(el => el.classList.remove('active-track'));
        const activeTrack = document.querySelector(`.track[data-id="${index}"]`);
        if (activeTrack) {
          activeTrack.classList.add('active-track');
          // Smoother, slower scroll to center the track
          activeTrack.scrollIntoView({ 
            behavior: 'smooth', 
            block: 'center',
            inline: 'nearest'
          });
        }
      }

      positionMapForTrack(track, index) {
        console.log('positionMapForTrack called for:', track.name);
        
        // Prevent multiple simultaneous map movements
        if (this.isPositioning) {
          console.log('Already positioning, skipping...');
          return;
        }
        this.isPositioning = true;

        const coords = [parseFloat(track.lng), parseFloat(track.lat)];
        
        const resetPositioning = () => {
          this.isPositioning = false;
        };

        // Calculate distance for duration scaling
        const currentCenter = map.getCenter();
        const distance = this.calculateDistance(
          currentCenter.lat, currentCenter.lng,
          coords[1], coords[0]
        );
        
        // Distance-based duration: longer for farther points
        const distanceKm = distance / 1000;
        let duration;
        if (distanceKm < 5) {
          duration = 2200; // Close points: normal speed
        } else if (distanceKm < 50) {
          duration = 2200 + ((distanceKm - 5) / 45) * 1800; // Medium: 2.2-4s
        } else {
          duration = Math.min(5000, 4000 + ((distanceKm - 50) / 100) * 1000); // Far: 4-5s max
        }

        // Smooth easing with pronounced landing deceleration
        const smoothLandingEasing = (t) => {
          if (t < 0.3) {
            // Gentle acceleration (30% of time)
            return 2 * t * t;
          } else if (t < 0.7) {
            // Steady cruise (40% of time)
            const localT = (t - 0.3) / 0.4;
            return 0.18 + 0.64 * localT; // Linear middle section
          } else {
            // Slow landing approach (30% of time)
            const localT = (t - 0.7) / 0.3;
            return 0.82 + 0.18 * (1 - Math.pow(1 - localT, 3));
          }
        };

        // Check if we're in 3D mode
        const is3D = uiController.is3DEnabled;
        const targetZoom = is3D ? CONFIG.ZOOM_3D : CONFIG.ZOOM_2D;

        const flyToOptions = {
          center: coords,
          zoom: targetZoom,
          duration,
          easing: smoothLandingEasing
        };
        
        // Add 3D properties for smoother rainbow arc
        if (is3D) {
          flyToOptions.pitch = 75;
          flyToOptions.bearing = map.getBearing();
          // Higher curve for ultra-smooth rainbow effect in 3D
          flyToOptions.curve = 2.5; // Even higher curve = smoother, more elevated arc
        }
        
        map.flyTo(flyToOptions);
        setTimeout(resetPositioning, duration + 200);
      }

      calculateDistance(lat1, lng1, lat2, lng2) {
        const R = 6371e3;
        const toRad = deg => deg * Math.PI / 180;
        const dLat = toRad(lat2 - lat1);
        const dLng = toRad(lng2 - lng1);
        const a = Math.sin(dLat / 2) ** 2 +
                  Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) * Math.sin(dLng / 2) ** 2;
        return 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)) * R;
      }

      showPopup(coords, track, audio, index) {
        if (this.currentPopup) {
          this.currentPopup.remove();
        }

        const container = document.createElement('div');
        container.style.fontFamily = 'helvetica, sans-serif';
        container.style.padding = '2px';

        const title = document.createElement('h3');
        title.textContent = track.name;
        title.style.margin = '0 0 4px 0';
        container.appendChild(title);

        const timestamp = document.createElement('p');
        timestamp.style.margin = '0';
        timestamp.style.fontSize = '0.9em';
        timestamp.style.color = '#555';
        timestamp.innerHTML = `<strong>${this.formatTimestamp(track.timestamp)}</strong>`;
        container.appendChild(timestamp);

        if (track.mile && track.mile.toString().trim().toLowerCase() !== 'n/a') {
          const displayMile = this.getDisplayMile(track);
          if (displayMile !== null) {
            const mile = document.createElement('p');
            mile.className = 'popup-mile';
            mile.style.margin = '0';
            mile.style.fontSize = '0.9em';
            mile.style.color = '#555';
            mile.innerHTML = `<strong>mi.${displayMile}</strong>`;
            container.appendChild(mile);
          }
        }

        if (track.notes?.trim()) {
          const notes = document.createElement('p');
          notes.style.margin = '4px 0';
          notes.style.fontSize = '0.9em';
          notes.textContent = track.notes;
          container.appendChild(notes);
        }

        const controls = document.createElement('div');
        controls.className = 'popup-controls';
        
        const prevBtn = document.createElement('button');
        prevBtn.className = 'nav-arrow';
        prevBtn.innerHTML = '&laquo;';
        prevBtn.title = 'Previous';
        
        // Disable previous button logic based on mode and history
        if (audioController.playMode === 'random') {
          prevBtn.disabled = audioController.playHistory.length === 0;
        } else {
          prevBtn.disabled = index === 0;
        }
        
        prevBtn.addEventListener('click', () => {
          audioController.playPrevious(this.audioData);
        });
        
        const nextBtn = document.createElement('button');
        nextBtn.className = 'nav-arrow';
        nextBtn.innerHTML = '&raquo;';
        nextBtn.title = 'Next';
        nextBtn.disabled = index === this.audioData.length - 1;
        nextBtn.addEventListener('click', () => {
          audioController.playNext(this.audioData);
        });
        
        controls.appendChild(prevBtn);
        
        if (audio) {
          const audioContainer = document.createElement('div');
          audioContainer.className = 'audio-container';
          audioContainer.id = 'audioContainer';
          
          // Ensure audio controls always render properly
          audio.controls = true;
          audio.autoplay = true;
          audio.style.width = '100%';
          audio.controlsList = 'nodownload';
          audio.oncontextmenu = () => false;
          
          // Force audio element to load controls
          audio.load();
          
          // Fallback: if controls don't appear, try recreating
          setTimeout(() => {
            if (!audio.controls || audio.offsetHeight === 0) {
              console.warn('Audio controls not rendering, attempting fix...');
              audio.controls = true;
              audio.style.display = 'block';
              audio.style.visibility = 'visible';
            }
          }, 100);
          
          audioContainer.appendChild(audio);
          controls.appendChild(audioContainer);
        }
        
        controls.appendChild(nextBtn);
        container.appendChild(controls);

        const popup = new mapboxgl.Popup({ 
          offset: 25,
          closeOnClick: false,
          closeOnMove: false,
          maxWidth: '400px'
        })
          .setLngLat(coords)
          .setDOMContent(container)
          .addTo(map);

        this.currentPopup = popup;
      }

      refreshPopupMileage(track) {
        if (!this.currentPopup) return;
        
        const popupContent = this.currentPopup._content;
        const mileElement = popupContent.querySelector('.popup-mile');
        if (mileElement && track.mile && track.mile.toString().trim().toLowerCase() !== 'n/a') {
          const displayMile = this.getDisplayMile(track);
          mileElement.innerHTML = `<strong>mi.${displayMile}</strong>`;
        }
      }

      formatTimestamp(timestamp) {
        // Enhanced timestamp formatting with proper 24hr display and PST/PDT
        const pacificDate = parsePacific(timestamp);
        const jsDate = pacificDate.toDate();
        
        if (!pacificDate.isValid()) {
          console.warn('Invalid timestamp:', timestamp);
          return String(timestamp || '');
        }
        
        // Format with 24-hour time
        const formatter = new Intl.DateTimeFormat('en-US', {
          timeZone: 'America/Los_Angeles',
          year: 'numeric',
          month: 'short',
          day: '2-digit',
          hour: '2-digit',
          minute: '2-digit',
          hour12: false // Force 24-hour format
        });
        
        // Get the timezone abbreviation (PST/PDT)
        const tzAbbr = isDST(jsDate) ? 'PDT' : 'PST';
        
        return formatter.format(jsDate) + ' ' + tzAbbr;
      }

      resetMap() {
        audioController.stop();
        uiController.clearMiniInfoBoxes();
        if (this.currentPopup) {
          this.currentPopup.remove();
          this.currentPopup = null;
        }
        
        // Disable 3D mode if it's enabled
        if (uiController.is3DEnabled) {
          uiController.is3DEnabled = false;
          const btn = document.getElementById('terrain3dBtn');
          btn.classList.remove('active');
          
          map.setTerrain(null);
          if (map.getSource('mapbox-dem')) {
            map.removeSource('mapbox-dem');
          }
        }
        
        // Reset atmospheric conditions to default
        if (typeof map.setSky === 'function') {
          map.setSky({
            'sky-type': 'atmosphere',
            'sky-atmosphere-sun': [180, 45],
            'sky-atmosphere-sun-intensity': 15
          });
        }
        
        if (typeof map.setFog === 'function') {
          map.setFog({
            'range': [0.5, 10],
            'color': 'white',
            'high-color': '#87CEEB',
            'space-color': '#000033',
            'horizon-blend': 0.1,
            'star-intensity': 0
          });
        }
        
        // Remove any atmospheric overlays
        const overlay = document.getElementById('atmosphere-overlay');
        if (overlay) {
          overlay.remove();
        }
        
        // Reset map style filters
        const mapContainer = document.getElementById('map');
        mapContainer.style.filter = 'none';
        
        map.flyTo({
          center: CONFIG.DEFAULT_CENTER,
          zoom: CONFIG.getDefaultZoom(),
          pitch: 0,
          bearing: 0,
          duration: 2000
        });
        
        document.querySelectorAll('.track').forEach(el => el.classList.remove('active-track'));
        
        showNotification('Map reset to default view', 2000);
      }

      getMovementDuration(track) {
        // Calculate the same duration logic used in positionMapForTrack
        const coords = [parseFloat(track.lng), parseFloat(track.lat)];
        const currentCenter = map.getCenter();
        const distance = this.calculateDistance(
          currentCenter.lat, currentCenter.lng,
          coords[1], coords[0]
        );
        
        const distanceKm = distance / 1000;
        let duration;
        if (distanceKm < 5) {
          duration = 2200;
        } else if (distanceKm < 50) {
          duration = 2200 + ((distanceKm - 5) / 45) * 1800;
        } else {
          duration = Math.min(5000, 4000 + ((distanceKm - 50) / 100) * 1000);
        }
        return duration;
      }
    }

    // Initialize controllers
    const audioController = new AudioController();
    const uiController = new UIController();
    const mapController = new MapController();
    const atmosphereController = new AtmosphereController();

    // Initialize map data update after first load
    setTimeout(() => {
      mapController.updateMapData();
    }, 1000);

  </script>

  <script src="https://storage.ko-fi.com/cdn/scripts/overlay-widget.js"></script>
  <script>
    kofiWidgetOverlay.draw('thmkly', {
      'type': 'floating-chat',
      'floating-chat.donateButton.text': 'Support me',
      'floating-chat.donateButton.background-color': '#ff5f5f',
      'floating-chat.donateButton.text-color': '#fff'
    });
  </script>
  <style>
    .floatingchat-container-wrap {
      left: unset !important;
      right: 16px !important;
      bottom: 30px !important;
    }
    .floating-chat-kofi-popup-iframe {
      left: unset !important;
      right: 16px !important;
      bottom: 30px !important;
    }
  </style>
</body>
</html>
