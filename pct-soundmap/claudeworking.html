<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>A Soundmap of the PCT, Stereo 2023</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link href="https://api.mapbox.com/mapbox-gl-js/v2.8.1/mapbox-gl.css" rel="stylesheet" />
<style>
  body {
    margin: 0;
    padding: 0;
    font-family: helvetica, sans-serif;
  }

  #map {
    position: absolute;
    top: 0;
    bottom: 0;
    width: 100%;
  }

  /* Playlist Styles */
  .playlist-wrapper {
    position: absolute;
    top: 25px;
    left: 10px;
    width: 350px;
    max-height: 84vh;
    border-radius: 5px;
    box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
    background-color: rgba(255, 255, 255, 0.75);
    font-family: helvetica;
    font-size: small;
    display: flex;
    flex-direction: column;
    align-items: stretch;
    z-index: 2;
    transition: transform 0.3s ease;
  }

  .playlist-wrapper.collapsed {
    transform: translateX(-340px);
  }

  .playlist-toggle {
    position: absolute;
    right: -30px;
    top: 50%;
    transform: translateY(-50%);
    width: 30px;
    height: 60px;
    background-color: rgba(255, 255, 255, 0.8);
    border: none;
    border-radius: 0 5px 5px 0;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 16px;
    color: #333;
    box-shadow: 2px 0 5px rgba(0, 0, 0, 0.2);
  }

  .playlist-toggle:hover {
    background-color: rgba(255, 255, 255, 0.95);
  }

  .playlist {
    overflow-y: auto;
    max-height: 85vh;
    padding: 5px;
    cursor: grab;
    user-select: none;
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
  }

  .playlist.dragging {
    cursor: grabbing;
  }

  .scroll-arrow {
    text-align: center;
    font-size: 12px;
    color: black;
    padding: 4px 0;
    user-select: none;
    cursor: pointer;
    display: none;
  }

  .track {
    cursor: pointer;
    padding: 5px;
    margin: 1px;
    border-bottom: 1px solid #ccc;
    display: flex;
    justify-content: space-between;
    align-items: center;
  }

  .track:hover {
    background-color: #f0f0f0;
  }

  .active-track {
    background-color: #d0d0d0;
  }

  .track-info {
    flex: 1;
  }

  .track-mile {
    font-size: 0.8em;
    color: #666;
    min-width: 40px;
    text-align: right;
  }

  /* Control Panel */
  .control-panel {
    position: absolute;
    top: 25px;
    right: 25px;
    background-color: rgba(255, 255, 255, 0.9);
    border-radius: 5px;
    box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
    padding: 10px;
    z-index: 2;
    display: flex;
    flex-direction: column;
    gap: 8px;
  }

  .control-row {
    display: flex;
    gap: 8px;
  }

  .control-btn {
    padding: 6px 12px;
    border: 1px solid #ccc;
    border-radius: 3px;
    background-color: white;
    cursor: pointer;
    font-size: 12px;
    transition: all 0.2s;
  }

  .control-btn:hover {
    background-color: #f0f0f0;
  }

  .control-btn.active {
    background-color: #5c3a2e;
    color: white;
    border-color: #5c3a2e;
  }

  .sort-controls {
    display: flex;
    gap: 4px;
  }

  .sort-btn {
    padding: 4px 8px;
    font-size: 11px;
  }

  /* Mini Info Boxes */
  .mini-infobox {
    position: absolute;
    background: rgba(255, 255, 255, 0.95);
    border: 1px solid #ccc;
    border-radius: 4px;
    padding: 4px 8px;
    font-size: 11px;
    color: #333;
    pointer-events: auto;
    cursor: pointer;
    z-index: 1;
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
    display: flex;
    align-items: center;
    gap: 4px;
    max-width: 150px;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }

  .mini-infobox:hover {
    background: rgba(255, 255, 255, 1);
  }

  .play-icon {
    width: 0;
    height: 0;
    border-left: 6px solid #5c3a2e;
    border-top: 4px solid transparent;
    border-bottom: 4px solid transparent;
    flex-shrink: 0;
  }

  /* Popup Controls */
  .popup-controls {
    display: flex;
    justify-content: center;
    gap: 10px;
    margin: 8px 0;
  }

  .popup-btn {
    background: #5c3a2e;
    color: white;
    border: none;
    border-radius: 3px;
    padding: 4px 8px;
    cursor: pointer;
    font-size: 12px;
  }

  .popup-btn:hover {
    background: #4a2e24;
  }

  .popup-btn:disabled {
    background: #ccc;
    cursor: not-allowed;
  }

  /* Cluster Tooltip */
  .cluster-tooltip {
    background: rgba(255, 255, 255, 0.95);
    border: 1px solid #ccc;
    border-radius: 4px;
    padding: 8px;
    font-size: 12px;
    max-width: 200px;
    max-height: 150px;
    overflow-y: auto;
    z-index: 1000;
  }

  .cluster-item {
    padding: 2px 0;
    cursor: pointer;
    border-bottom: 1px solid #eee;
  }

  .cluster-item:hover {
    background-color: #f0f0f0;
  }

  .cluster-item:last-child {
    border-bottom: none;
  }

  /* Map Controls */
  .mapboxgl-canvas {
    cursor: grab;
  }

  .mapboxgl-popup-content {
    opacity: 0.8;
    transition: opacity 0.3s ease;
    min-width: 320px;
    max-width: 90vw;
    box-sizing: border-box;
  }

  .mapboxgl-popup-close-button:focus {
    outline: none;
    box-shadow: none;
  }

  .loading-placeholder {
    text-align: center;
    color: #555;
    padding: 8px;
  }

  /* Responsive adjustments */
  @media (max-width: 768px) {
    .playlist-wrapper {
      width: 300px;
    }
    
    .control-panel {
      right: 10px;
      top: 10px;
    }
    
    .mini-infobox {
      max-width: 120px;
    }
  }

  /* Fullscreen styles */
  .fullscreen-active {
    position: fixed !important;
    top: 0 !important;
    left: 0 !important;
    width: 100vw !important;
    height: 100vh !important;
    z-index: 9999 !important;
  }
</style>
</head>
<body>
  <div id="map"></div>
  
  <div class="playlist-wrapper" id="playlistWrapper">
    <button class="playlist-toggle" id="playlistToggle">◀</button>
    <div class="scroll-arrow up" id="scrollUp">▲</div>
    <div class="playlist" id="playlist">
      <div class="loading-placeholder">loading recordings...</div>
    </div>
    <div class="scroll-arrow down" id="scrollDown">▼</div>
  </div>

  <div class="control-panel">
    <div class="control-row">
      <button class="control-btn" id="randomizeBtn">Random</button>
      <button class="control-btn" id="resetMapBtn">Reset Map</button>
      <button class="control-btn" id="fullscreenBtn">Fullscreen</button>
      <button class="control-btn" id="terrain3dBtn">3D Terrain</button>
    </div>
    <div class="sort-controls">
      <button class="control-btn sort-btn active" id="sortNobo">NOBO</button>
      <button class="control-btn sort-btn" id="sortSobo">SOBO</button>
      <button class="control-btn sort-btn" id="sortDate">Date</button>
      <button class="control-btn sort-btn" id="sortRandom">Shuffle</button>
    </div>
  </div>

  <script src="https://api.mapbox.com/mapbox-gl-js/v2.8.1/mapbox-gl.js"></script>
  <script src="config.js"></script>
  <script>
    // Configuration - move your token to config.js file
    const CONFIG = {
      MAPBOX_TOKEN: window.MAPBOX_CONFIG?.token || 'pk.eyJ1IjoidGhta2x5IiwiYSI6ImNseXVyMjhueDA3YTQybW9mcHJrZGJ3YnEifQ.Nv-LsNg5eKIE6SeOVVJpYg', // fallback
      GOOGLE_SCRIPT_URL: 'https://script.google.com/macros/s/AKfycbzBPYMFDZDbzKPtCqjjgyqRQlVhKXfLZ9yGERjAHXv5ZZ-H-r1oUgVrnxysd4jN6kfw/exec',
      DEFAULT_CENTER: [-122.50276, 41.31727],
      getDefaultZoom: () => {
        const screenWidth = window.screen.width;
        if (screenWidth <= 1366) return 4.625;
        if (screenWidth <= 1920) return 5;
        return 5.25;
      },
      getClusterRadius: () => {
        const screenWidth = window.screen.width;
        if (screenWidth <= 1366) return 45;
        if (screenWidth <= 1920) return 50;
        return 55;
      }
    };

    // Audio Controller Class
    class AudioController {
      constructor() {
        this.currentAudio = null;
        this.currentIndex = -1;
        this.isPlaying = false;
        this.playMode = 'sequential'; // sequential, random
        this.sortMode = 'nobo'; // nobo, sobo, date, random
        this.playQueue = [];
        this.setupWakeLock();
      }

      async setupWakeLock() {
        if ('wakeLock' in navigator) {
          try {
            this.wakeLock = await navigator.wakeLock.request('screen');
          } catch (err) {
            console.log('Wake lock not supported');
          }
        }
      }

      play(index, audioData) {
        if (this.currentAudio) {
          this.currentAudio.pause();
          this.currentAudio = null;
        }

        const track = audioData[index];
        if (!track) return;

        this.currentIndex = index;
        this.isPlaying = true;

        // Create and configure audio element
        const audio = document.createElement('audio');
        audio.src = track.audioUrl;
        audio.preload = 'auto';
        
        // Disable download/context menu
        audio.controlsList = 'nodownload';
        audio.oncontextmenu = () => false;
        
        // Auto-continue to next track
        audio.addEventListener('ended', () => {
          this.playNext(audioData);
        });

        audio.addEventListener('error', () => {
          console.warn('Audio failed to load:', track.name);
          this.playNext(audioData);
        });

        this.currentAudio = audio;
        return audio;
      }

      togglePlayPause() {
        if (!this.currentAudio) return;
        
        if (this.currentAudio.paused) {
          this.currentAudio.play();
          this.isPlaying = true;
        } else {
          this.currentAudio.pause();
          this.isPlaying = false;
        }
      }

      playNext(audioData) {
        let nextIndex;
        
        if (this.playMode === 'random') {
          nextIndex = Math.floor(Math.random() * audioData.length);
        } else {
          nextIndex = this.currentIndex + 1;
          if (nextIndex >= audioData.length) {
            nextIndex = 0; // Loop back to start
          }
        }
        
        if (nextIndex !== this.currentIndex) {
          mapController.playAudio(nextIndex);
        }
      }

      playPrevious(audioData) {
        let prevIndex = this.currentIndex - 1;
        if (prevIndex < 0) {
          prevIndex = audioData.length - 1;
        }
        mapController.playAudio(prevIndex);
      }

      stop() {
        if (this.currentAudio) {
          this.currentAudio.pause();
          this.currentAudio = null;
        }
        this.isPlaying = false;
        this.currentIndex = -1;
      }
    }

    // UI Controller Class
    class UIController {
      constructor() {
        this.playlistExpanded = true;
        this.isFullscreen = false;
        this.is3DEnabled = false;
        this.miniInfoBoxes = [];
        this.clusterTooltip = null;
        this.setupEventListeners();
      }

      setupEventListeners() {
        // Playlist toggle
        document.getElementById('playlistToggle').addEventListener('click', () => {
          this.togglePlaylist();
        });

        // Sort buttons
        document.querySelectorAll('.sort-btn').forEach(btn => {
          btn.addEventListener('click', (e) => {
            this.handleSortChange(e.target.id);
          });
        });

        // Control buttons
        document.getElementById('randomizeBtn').addEventListener('click', () => {
          audioController.playMode = audioController.playMode === 'random' ? 'sequential' : 'random';
          this.updateRandomButton();
        });

        document.getElementById('resetMapBtn').addEventListener('click', () => {
          mapController.resetMap();
        });

        document.getElementById('fullscreenBtn').addEventListener('click', () => {
          this.toggleFullscreen();
        });

        document.getElementById('terrain3dBtn').addEventListener('click', () => {
          this.toggle3D();
        });

        // Global spacebar handler
        document.addEventListener('keydown', (e) => {
          if (e.code === 'Space' && audioController.currentAudio) {
            e.preventDefault();
            audioController.togglePlayPause();
          }
        });

        // Scroll arrows
        const playlist = document.getElementById('playlist');
        const scrollUp = document.getElementById('scrollUp');
        const scrollDown = document.getElementById('scrollDown');

        playlist.addEventListener('scroll', () => this.updateScrollArrows());
        scrollUp.addEventListener('click', () => playlist.scrollBy({ top: -100, behavior: 'smooth' }));
        scrollDown.addEventListener('click', () => playlist.scrollBy({ top: 100, behavior: 'smooth' }));

        this.setupPlaylistDrag();
      }

      togglePlaylist() {
        const wrapper = document.getElementById('playlistWrapper');
        const toggle = document.getElementById('playlistToggle');
        
        this.playlistExpanded = !this.playlistExpanded;
        
        if (this.playlistExpanded) {
          wrapper.classList.remove('collapsed');
          toggle.textContent = '◀';
        } else {
          wrapper.classList.add('collapsed');
          toggle.textContent = '▶';
        }
      }

      handleSortChange(sortId) {
        // Update active button
        document.querySelectorAll('.sort-btn').forEach(btn => btn.classList.remove('active'));
        document.getElementById(sortId).classList.add('active');

        // Update sort mode
        const sortMap = {
          'sortNobo': 'nobo',
          'sortSobo': 'sobo',
          'sortDate': 'date',
          'sortRandom': 'random'
        };
        
        audioController.sortMode = sortMap[sortId];
        mapController.sortAndUpdatePlaylist();
      }

      updateRandomButton() {
        const btn = document.getElementById('randomizeBtn');
        btn.classList.toggle('active', audioController.playMode === 'random');
        btn.textContent = audioController.playMode === 'random' ? 'Sequential' : 'Random';
      }

      toggleFullscreen() {
        const mapEl = document.getElementById('map');
        
        if (!this.isFullscreen) {
          if (mapEl.requestFullscreen) {
            mapEl.requestFullscreen();
          } else if (mapEl.webkitRequestFullscreen) {
            mapEl.webkitRequestFullscreen();
          } else if (mapEl.msRequestFullscreen) {
            mapEl.msRequestFullscreen();
          }
        } else {
          if (document.exitFullscreen) {
            document.exitFullscreen();
          } else if (document.webkitExitFullscreen) {
            document.webkitExitFullscreen();
          } else if (document.msExitFullscreen) {
            document.msExitFullscreen();
          }
        }
      }

      toggle3D() {
        this.is3DEnabled = !this.is3DEnabled;
        const btn = document.getElementById('terrain3dBtn');
        btn.classList.toggle('active', this.is3DEnabled);

        if (this.is3DEnabled) {
          map.addSource('mapbox-dem', {
            'type': 'raster-dem',
            'url': 'mapbox://mapbox.mapbox-terrain-dem-v1',
            'tileSize': 512,
            'maxzoom': 14
          });
          map.setTerrain({ 'source': 'mapbox-dem', 'exaggeration': 1.5 });
          map.setPitch(45);
        } else {
          map.setTerrain(null);
          map.setPitch(0);
          if (map.getSource('mapbox-dem')) {
            map.removeSource('mapbox-dem');
          }
        }
      }

      updateScrollArrows() {
        const playlist = document.getElementById('playlist');
        const scrollUp = document.getElementById('scrollUp');
        const scrollDown = document.getElementById('scrollDown');
        
        scrollUp.style.display = playlist.scrollTop > 0 ? 'block' : 'none';
        scrollDown.style.display = (playlist.scrollTop + playlist.clientHeight) < playlist.scrollHeight ? 'block' : 'none';
      }

      setupPlaylistDrag() {
        const playlist = document.getElementById('playlist');
        let dragging = false, startY, scrollStart, vel = 0, lastY = 0, lastTime = 0, raf;
        let dragStarted = false, preventClick = false;

        playlist.addEventListener('mousedown', e => {
          dragging = true;
          dragStarted = false;
          playlist.classList.add('dragging');
          startY = e.pageY;
          scrollStart = playlist.scrollTop;
          vel = 0;
          lastY = e.pageY;
          lastTime = Date.now();
          if (raf) cancelAnimationFrame(raf);
        });

        playlist.addEventListener('mousemove', e => {
          if (!dragging) return;
          e.preventDefault();
          const now = Date.now();
          const dy = e.pageY - lastY;
          const dt = now - lastTime;
          if (dt > 0) vel = dy / dt * 16;
          playlist.scrollTop = scrollStart - (e.pageY - startY);
          lastY = e.pageY;
          lastTime = now;
          this.updateScrollArrows();

          if (!dragStarted && Math.abs(e.pageY - startY) > 5) {
            dragStarted = true;
            preventClick = true;
          }
        });

        ['mouseup', 'mouseleave'].forEach(ev => {
          playlist.addEventListener(ev, () => {
            if (!dragging) return;
            dragging = false;
            playlist.classList.remove('dragging');
            
            // Momentum scrolling
            const momentum = () => {
              if (Math.abs(vel) < 0.5) return;
              playlist.scrollTop -= vel;
              vel *= 0.95;
              raf = requestAnimationFrame(momentum);
              this.updateScrollArrows();
            };
            momentum();

            // Reset prevent click after a delay
            if (preventClick) {
              setTimeout(() => { preventClick = false; }, 100);
            }
          });
        });

        // Handle click prevention
        playlist.addEventListener('click', e => {
          if (preventClick) {
            e.preventDefault();
            e.stopPropagation();
          }
        }, true);
      }

      showMiniInfoBoxes(currentTrack, audioData) {
        this.clearMiniInfoBoxes();

        // Get current track mile for reference
        const currentMile = parseFloat(currentTrack.mile) || 0;
        
        // Find adjacent tracks (visible single points only)
        const visiblePoints = map.queryRenderedFeatures({ layers: ['unclustered-point'] });
        
        visiblePoints.forEach(point => {
          const trackIndex = parseInt(point.properties.id);
          if (trackIndex === audioController.currentIndex) return;
          
          const track = audioData[trackIndex];
          if (!track) return;

          const coords = point.geometry.coordinates;
          const pixelCoords = map.project(coords);
          
          const infoBox = document.createElement('div');
          infoBox.className = 'mini-infobox';
          infoBox.innerHTML = `
            <div class="play-icon"></div>
            <span>${track.name.replace(/^[^\s]+\s+-\s+/, '')}</span>
          `;
          
          infoBox.style.left = `${pixelCoords.x + 10}px`;
          infoBox.style.top = `${pixelCoords.y - 20}px`;
          
          infoBox.addEventListener('click', () => {
            mapController.playAudio(trackIndex);
          });
          
          map.getContainer().appendChild(infoBox);
          this.miniInfoBoxes.push(infoBox);
        });
      }

      clearMiniInfoBoxes() {
        this.miniInfoBoxes.forEach(box => {
          if (box.parentNode) {
            box.parentNode.removeChild(box);
          }
        });
        this.miniInfoBoxes = [];
      }

      showClusterTooltip(e, leaves) {
        this.hideClusterTooltip();

        const tooltip = document.createElement('div');
        tooltip.className = 'cluster-tooltip';
        
        leaves.forEach(leaf => {
          const item = document.createElement('div');
          item.className = 'cluster-item';
          item.textContent = leaf.properties.name.replace(/^[^\s]+\s+-\s+/, '');
          item.addEventListener('click', () => {
            mapController.playAudio(parseInt(leaf.properties.id));
            this.hideClusterTooltip();
          });
          tooltip.appendChild(item);
        });

        tooltip.style.position = 'absolute';
        tooltip.style.left = `${e.point.x + 10}px`;
        tooltip.style.top = `${e.point.y - 10}px`;
        
        map.getContainer().appendChild(tooltip);
        this.clusterTooltip = tooltip;
      }

      hideClusterTooltip() {
        if (this.clusterTooltip) {
          this.clusterTooltip.remove();
          this.clusterTooltip = null;
        }
      }
    }

    // Map Controller Class
    class MapController {
      constructor() {
        this.audioData = [];
        this.currentPopup = null;
        this.consistentZoom = 10; // Consistent zoom level for playing sounds
        this.setupMap();
      }

      setupMap() {
        mapboxgl.accessToken = CONFIG.MAPBOX_TOKEN;
        
        window.map = new mapboxgl.Map({
          container: 'map',
          style: 'mapbox://styles/thmkly/clyup637d004201ri2tkpaywq',
          center: CONFIG.DEFAULT_CENTER,
          zoom: CONFIG.getDefaultZoom()
        });

        map.on('load', () => {
          this.setupMapLayers();
          this.setupMapEvents();
          this.loadAudioData();
        });
      }

      setupMapLayers() {
        map.addSource('audio', {
          type: 'geojson',
          data: { type: 'FeatureCollection', features: [] },
          cluster: true,
          clusterMaxZoom: 14,
          clusterRadius: CONFIG.getClusterRadius()
        });

        // Cluster layer
        map.addLayer({
          id: 'clusters',
          type: 'circle',
          source: 'audio',
          filter: ['has', 'point_count'],
          paint: {
            'circle-color': '#51bbd6',
            'circle-opacity': 0.7,
            'circle-stroke-width': 1,
            'circle-stroke-color': '#197991',
            'circle-stroke-opacity': 0.75,
            'circle-radius': [
              'step',
              ['get', 'point_count'],
              18, 3, 22, 5, 26, 6, 30, 7, 34, 8, 36,
              10, 38, 15, 40, 18, 42, 22, 44, 25, 46,
              30, 48, 35, 50, 40, 52, 50, 54, 100, 56
            ]
          }
        });

        // Cluster count layer
        map.addLayer({
          id: 'cluster-count',
          type: 'symbol',
          source: 'audio',
          filter: ['has', 'point_count'],
          layout: {
            'text-field': '{point_count_abbreviated}',
            'text-font': ['Open Sans Semibold', 'Arial Unicode MS Bold'],
            'text-size': 12
          }
        });

        // Individual points layer
        map.addLayer({
          id: 'unclustered-point',
          type: 'circle',
          source: 'audio',
          filter: ['!', ['has', 'point_count']],
          paint: {
            'circle-color': '#5c3a2e',
            'circle-radius': 6,
            'circle-opacity': 0.6,
            'circle-stroke-width': 1,
            'circle-stroke-color': '#fff',
            'circle-stroke-opacity': 0.8
          }
        });
      }

      setupMapEvents() {
        // Cursor changes
        ['clusters', 'unclustered-point'].forEach(layer => {
          map.on('mouseenter', layer, () => map.getCanvas().style.cursor = 'pointer');
          map.on('mouseleave', layer, () => map.getCanvas().style.cursor = '');
        });

        // Cluster click - expand view
        map.on('click', 'clusters', (e) => {
          const features = map.queryRenderedFeatures(e.point, { layers: ['clusters'] });
          if (!features.length) return;
          
          const clusterId = features[0].properties.cluster_id;
          map.getSource('audio').getClusterExpansionZoom(clusterId, (err, zoom) => {
            if (err) return;
            map.getSource('audio').getClusterLeaves(clusterId, 100, 0, (_, leaves) => {
              const bounds = new mapboxgl.LngLatBounds();
              leaves.forEach(leaf => bounds.extend(leaf.geometry.coordinates));
              map.fitBounds(bounds, { 
                padding: { top: 50, bottom: 50, left: this.getLeftPadding(), right: 20 } 
              });
            });
          });
        });

        // Cluster hover - show tooltip
        map.on('mouseenter', 'clusters', (e) => {
          const features = map.queryRenderedFeatures(e.point, { layers: ['clusters'] });
          if (!features.length) return;
          
          const clusterId = features[0].properties.cluster_id;
          map.getSource('audio').getClusterLeaves(clusterId, 100, 0, (_, leaves) => {
            uiController.showClusterTooltip(e, leaves);
          });
        });

        map.on('mouseleave', 'clusters', () => {
          uiController.hideClusterTooltip();
        });

        // Point click - play audio
        map.on('click', 'unclustered-point', (e) => {
          const feature = e.features[0];
          if (!feature) return;
          const index = parseInt(feature.properties.id);
          this.playAudio(index);
        });

        // Map move/zoom - update mini infoboxes
        map.on('move', () => {
          if (audioController.currentIndex >= 0) {
            uiController.showMiniInfoBoxes(this.audioData[audioController.currentIndex], this.audioData);
          }
        });

        // Fullscreen events
        document.addEventListener('fullscreenchange', () => {
          uiController.isFullscreen = !!document.fullscreenElement;
          const btn = document.getElementById('fullscreenBtn');
          btn.textContent = uiController.isFullscreen ? 'Exit Fullscreen' : 'Fullscreen';
          btn.classList.toggle('active', uiController.isFullscreen);
        });
      }

      getLeftPadding() {
        return uiController.playlistExpanded ? 370 : 20;
      }

      loadAudioData() {
        const url = `${CONFIG.GOOGLE_SCRIPT_URL}?nocache=${Date.now()}`;
        fetch(url)
          .then(r => r.json())
          .then(data => {
            this.audioData = data;
            this.sortAndUpdatePlaylist();
          })
          .catch(e => {
            console.error(e);
            document.getElementById('playlist').innerHTML = '<p class="loading-placeholder">Failed to load recordings.</p>';
          });
      }

      sortAndUpdatePlaylist() {
        let sortedData = [...this.audioData];
        
        switch (audioController.sortMode) {
          case 'nobo':
            sortedData.sort((a, b) => {
              const mileA = parseFloat(a.mile) || 0;
              const mileB = parseFloat(b.mile) || 0;
              return mileA - mileB;
            });
            break;
          case 'sobo':
            sortedData.sort((a, b) => {
              const mileA = parseFloat(a.mile) || 0;
              const mileB = parseFloat(b.mile) || 0;
              return mileB - mileA;
            });
            break;
          case 'date':
            sortedData.sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));
            break;
          case 'random':
            sortedData = this.shuffleArray(sortedData);
            break;
        }
        
        this.audioData = sortedData;
        this.updateMapData();
        this.updatePlaylist();
      }

      shuffleArray(array) {
        const shuffled = [...array];
        for (let i = shuffled.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
        }
        return shuffled;
      }

      updateMapData() {
        const source = map.getSource('audio');
        if (!source) return;
        
        const geojson = {
          type: 'FeatureCollection',
          features: this.audioData.map((track, index) => ({
            type: 'Feature',
            geometry: { 
              type: 'Point', 
              coordinates: [parseFloat(track.lng), parseFloat(track.lat)] 
            },
            properties: { 
              ...track, 
              id: index,
              mile: track.mile || 'N/A'
            }
          }))
        };
        
        source.setData(geojson);
      }

      updatePlaylist() {
        const playlist = document.getElementById('playlist');
        playlist.innerHTML = '';
        
        this.audioData.forEach((track, index) => {
          const div = document.createElement('div');
          div.className = 'track';
          div.dataset.id = index;
          
          const trackInfo = document.createElement('div');
          trackInfo.className = 'track-info';
          trackInfo.textContent = track.name.replace(/^[^\s]+\s+-\s+/, '');
          
          const trackMile = document.createElement('div');
          trackMile.className = 'track-mile';
          const mile = track.mile && track.mile.toString().trim().toLowerCase() !== 'n/a' ? `mi.${track.mile}` : '';
          trackMile.textContent = mile;
          
          div.appendChild(trackInfo);
          div.appendChild(trackMile);
          
          div.addEventListener('click', (e) => {
            this.playAudio(index);
          });
          
          playlist.appendChild(div);
        });
        
        uiController.updateScrollArrows();
      }

      playAudio(index) {
        const track = this.audioData[index];
        if (!track) return;

        // Update UI
        this.updateActiveTrack(index);
        
        // Create audio and get player element
        const audio = audioController.play(index, this.audioData);
        
        // Position map and show popup
        this.positionMapForTrack(track, index);
        this.showPopup([parseFloat(track.lng), parseFloat(track.lat)], track, audio, index);
        
        // Show mini infoboxes for adjacent points
        uiController.showMiniInfoBoxes(track, this.audioData);
      }

      updateActiveTrack(index) {
        document.querySelectorAll('.track').forEach(el => el.classList.remove('active-track'));
        const activeTrack = document.querySelector(`.track[data-id="${index}"]`);
        if (activeTrack) {
          activeTrack.classList.add('active-track');
          activeTrack.scrollIntoView({ behavior: 'smooth', block: 'center' });
        }
      }

      positionMapForTrack(track, index) {
        const coords = [parseFloat(track.lng), parseFloat(track.lat)];
        
        // Find adjacent tracks by mile for better context
        const currentMile = parseFloat(track.mile) || 0;
        const adjacentTracks = this.audioData
          .map((t, i) => ({ ...t, index: i, mile: parseFloat(t.mile) || 0 }))
          .filter(t => t.index !== index && Math.abs(t.mile - currentMile) <= 50) // Within 50 miles
          .sort((a, b) => Math.abs(a.mile - currentMile) - Math.abs(b.mile - currentMile))
          .slice(0, 4); // Show up to 4 adjacent tracks for context

        if (adjacentTracks.length > 0) {
          const bounds = new mapboxgl.LngLatBounds();
          bounds.extend(coords);
          
          adjacentTracks.forEach(t => {
            bounds.extend([parseFloat(t.lng), parseFloat(t.lat)]);
          });
          
          // Calculate animation duration based on distance
          const currentCenter = map.getCenter();
          const targetCenter = bounds.getCenter();
          const distance = this.calculateDistance(
            currentCenter.lat, currentCenter.lng,
            targetCenter.lat, targetCenter.lng
          );
          const duration = Math.max(2200, Math.min(5000, 700 * Math.sqrt(distance / 1000)));
          
          map.fitBounds(bounds, {
            padding: { 
              top: 120, 
              bottom: 120, 
              left: this.getLeftPadding(), 
              right: 120 
            },
            duration,
            easing: t => t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t
          });
        } else {
          // Fallback to consistent zoom
          map.flyTo({
            center: coords,
            zoom: this.consistentZoom,
            duration: 2500,
            easing: t => t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t
          });
        }
      }

      calculateDistance(lat1, lng1, lat2, lng2) {
        const R = 6371e3; // Earth's radius in meters
        const toRad = deg => deg * Math.PI / 180;
        const dLat = toRad(lat2 - lat1);
        const dLng = toRad(lng2 - lng1);
        const a = Math.sin(dLat / 2) ** 2 +
                  Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) * Math.sin(dLng / 2) ** 2;
        return 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)) * R;
      }

      showPopup(coords, track, audio, index) {
        if (this.currentPopup) {
          this.currentPopup.remove();
        }

        const container = document.createElement('div');
        container.style.fontFamily = 'helvetica, sans-serif';
        container.style.padding = '2px';

        // Title
        const title = document.createElement('h3');
        title.textContent = track.name;
        title.style.margin = '0 0 4px 0';
        container.appendChild(title);

        // Timestamp
        const timestamp = document.createElement('p');
        timestamp.style.margin = '0';
        timestamp.style.fontSize = '0.9em';
        timestamp.style.color = '#555';
        timestamp.innerHTML = `<strong>${this.formatTimestamp(track.timestamp)}</strong>`;
        container.appendChild(timestamp);

        // Mile marker
        if (track.mile && track.mile.toString().trim().toLowerCase() !== 'n/a') {
          const mile = document.createElement('p');
          mile.style.margin = '0';
          mile.style.fontSize = '0.9em';
          mile.style.color = '#555';
          mile.innerHTML = `<strong>mi.${track.mile}</strong>`;
          container.appendChild(mile);
        }

        // Notes
        if (track.notes?.trim()) {
          const notes = document.createElement('p');
          notes.style.margin = '4px 0';
          notes.style.fontSize = '0.9em';
          notes.textContent = track.notes;
          container.appendChild(notes);
        }

        // Previous/Next controls
        const controls = document.createElement('div');
        controls.className = 'popup-controls';
        
        const prevBtn = document.createElement('button');
        prevBtn.className = 'popup-btn';
        prevBtn.textContent = '← Previous';
        prevBtn.disabled = index === 0;
        prevBtn.addEventListener('click', () => {
          audioController.playPrevious(this.audioData);
        });
        
        const nextBtn = document.createElement('button');
        nextBtn.className = 'popup-btn';
        nextBtn.textContent = 'Next →';
        nextBtn.disabled = index === this.audioData.length - 1;
        nextBtn.addEventListener('click', () => {
          audioController.playNext(this.audioData);
        });
        
        controls.appendChild(prevBtn);
        controls.appendChild(nextBtn);
        container.appendChild(controls);

        // Audio player
        audio.controls = true;
        audio.autoplay = true;
        audio.style.width = '100%';
        audio.controlsList = 'nodownload';
        audio.oncontextmenu = () => false;
        
        container.appendChild(audio);

        // Create popup with better positioning
        const popup = new mapboxgl.Popup({ 
          offset: 25,
          closeOnClick: false,
          closeOnMove: false,
          maxWidth: '400px'
        })
          .setLngLat(coords)
          .setDOMContent(container)
          .addTo(map);

        this.currentPopup = popup;
        
        // Ensure popup stays visible
        popup.on('close', () => {
          if (audioController.currentAudio && !audioController.currentAudio.paused) {
            // Don't close if audio is still playing
            setTimeout(() => {
              if (!this.currentPopup) {
                popup.addTo(map);
                this.currentPopup = popup;
              }
            }, 100);
          }
        });
      }

      formatTimestamp(timestamp) {
        const date = new Date(timestamp);
        if (isNaN(date)) return timestamp;
        
        const options = {
          timeZone: 'America/Los_Angeles',
          year: 'numeric',
          month: '2-digit',
          day: '2-digit',
          hour: '2-digit',
          minute: '2-digit',
          hour12: false
        };
        
        const parts = new Intl.DateTimeFormat('en-CA', options).formatToParts(date);
        const get = type => parts.find(p => p.type === type)?.value;
        return `${get('year')}-${get('month')}-${get('day')} ${get('hour')}:${get('minute')} PDT`;
      }

      resetMap() {
        // Clear current audio and UI
        audioController.stop();
        uiController.clearMiniInfoBoxes();
        if (this.currentPopup) {
          this.currentPopup.remove();
          this.currentPopup = null;
        }
        
        // Reset map view
        map.flyTo({
          center: CONFIG.DEFAULT_CENTER,
          zoom: CONFIG.getDefaultZoom(),
          pitch: 0,
          bearing: 0,
          duration: 2000
        });
        
        // Clear active track
        document.querySelectorAll('.track').forEach(el => el.classList.remove('active-track'));
      }
    }

    // Initialize controllers
    const audioController = new AudioController();
    const uiController = new UIController();
    const mapController = new MapController();

    // Ko-fi widget (keeping your existing widget)
  </script>

  <script src="https://storage.ko-fi.com/cdn/scripts/overlay-widget.js"></script>
  <script>
    kofiWidgetOverlay.draw('thmkly', {
      'type': 'floating-chat',
      'floating-chat.donateButton.text': 'Support me',
      'floating-chat.donateButton.background-color': '#ff5f5f',
      'floating-chat.donateButton.text-color': '#fff'
    });
  </script>
  <style>
    .floatingchat-container-wrap {
      left: unset !important;
      right: 16px !important;
      bottom: 30px !important;
    }
    .floating-chat-kofi-popup-iframe {
      left: unset !important;
      right: 16px !important;
      bottom: 30px !important;
    }
  </style>
</body>
</html>
