<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>A Soundmap of the PCT, Stereo 2023</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link href="https://api.mapbox.com/mapbox-gl-js/v2.8.1/mapbox-gl.css" rel="stylesheet" />
<style>
  body {
    margin: 0;
    padding: 0;
    font-family: helvetica, sans-serif;
  }

  #map {
    position: absolute;
    top: 0;
    bottom: 0;
    width: 100%;
  }

  /* Playlist Styles */
  .playlist-wrapper {
    position: absolute;
    top: 25px;
    left: 10px;
    width: 350px;
    max-height: 84vh;
    border-radius: 5px;
    box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
    background-color: rgba(255, 255, 255, 0.75);
    font-family: helvetica;
    font-size: small;
    display: flex;
    flex-direction: column;
    align-items: stretch;
    z-index: 2;
    transition: transform 0.3s ease;
  }

  .playlist-wrapper.collapsed {
    transform: translateX(-360px);
  }

  .playlist-toggle {
    position: absolute;
    right: -20px;
    top: 50%;
    transform: translateY(-50%);
    width: 20px;
    height: 50px;
    background-color: rgba(255, 255, 255, 0.75);
    border: none;
    border-radius: 0 5px 5px 0;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 12px;
    color: #333;
    box-shadow: 2px 0 5px rgba(0, 0, 0, 0.2);
    z-index: 3;
    transition: background-color 0.2s;
    opacity: 0;
    transition: opacity 0.3s ease, background-color 0.2s;
  }

  .playlist-toggle.visible {
    opacity: 1;
  }

  .playlist-toggle:hover {
    background-color: rgba(255, 255, 255, 0.9);
  }

  .playlist-wrapper:not(.collapsed) .playlist-toggle {
    background-color: transparent;
    box-shadow: none;
  }

  .playlist {
    overflow-y: auto;
    max-height: 85vh;
    padding: 5px;
    cursor: grab;
    user-select: none;
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
  }

  .playlist.dragging {
    cursor: grabbing;
  }

  .scroll-arrow {
    text-align: center;
    font-size: 12px;
    color: black;
    padding: 4px 0;
    user-select: none;
    cursor: pointer;
    display: none;
  }

  .track {
    cursor: pointer;
    padding: 5px;
    margin: 1px;
    border-bottom: 1px solid #ccc;
    display: flex;
    justify-content: space-between;
    align-items: center;
  }

  .track:hover {
    background-color: #f0f0f0;
  }

  .active-track {
    background-color: #d0d0d0;
  }

  .track-info {
    flex: 1;
  }

  .track-mile {
    font-size: 0.8em;
    color: #666;
    min-width: 40px;
    text-align: right;
  }

  /* Control Panel */
  .control-panel {
    position: absolute;
    top: 25px;
    right: 25px;
    background-color: rgba(255, 255, 255, 0.9);
    border-radius: 5px;
    box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
    padding: 10px;
    z-index: 2;
    display: flex;
    flex-direction: column;
    gap: 8px;
  }

  .control-row {
    display: flex;
    gap: 8px;
  }

  .control-btn {
    padding: 6px 12px;
    border: 1px solid #ccc;
    border-radius: 3px;
    background-color: white;
    cursor: pointer;
    font-size: 12px;
    transition: all 0.2s;
  }

  .control-btn:hover {
    background-color: #f0f0f0;
  }

  .control-btn.active {
    background-color: #5c3a2e;
    color: white;
    border-color: #5c3a2e;
  }

  .sort-controls {
    display: flex;
    gap: 4px;
    align-items: center;
  }

  .sort-btn {
    padding: 4px 8px;
    font-size: 11px;
  }

  .random-control {
    display: flex;
    align-items: center;
    gap: 6px;
    margin-left: 8px;
  }

  .random-label {
    font-size: 11px;
    color: #333;
  }

  .toggle-switch {
    position: relative;
    width: 36px;
    height: 18px;
    background-color: #ccc;
    border-radius: 9px;
    cursor: pointer;
    transition: background-color 0.3s;
  }

  .toggle-switch.active {
    background-color: #5c3a2e;
  }

  .toggle-slider {
    position: absolute;
    top: 2px;
    left: 2px;
    width: 14px;
    height: 14px;
    background-color: white;
    border-radius: 50%;
    transition: transform 0.3s;
  }

  .toggle-switch.active .toggle-slider {
    transform: translateX(18px);
  }

  /* Mini Info Boxes */
  .mini-infobox {
    position: absolute;
    background: rgba(255, 255, 255, 0.85);
    border: 1px solid #ccc;
    border-radius: 4px;
    padding: 4px 8px;
    font-size: 11px;
    color: #333;
    pointer-events: auto;
    cursor: pointer;
    z-index: 1;
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
    display: flex;
    align-items: center;
    gap: 4px;
    max-width: 200px;
    white-space: nowrap;
    overflow: visible;
    transition: background-color 0.2s;
  }

  .mini-infobox:hover {
    background: rgba(240, 240, 240, 0.9);
  }

  .mini-infobox-title {
    flex: 1;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
    cursor: pointer;
  }

  .play-icon {
    width: 0;
    height: 0;
    border-left: 6px solid #5c3a2e;
    border-top: 4px solid transparent;
    border-bottom: 4px solid transparent;
    flex-shrink: 0;
    cursor: pointer;
  }

  .play-icon:hover {
    border-left-color: #4a2e24;
  }

  /* Popup Controls */
  .popup-controls {
    display: flex;
    justify-content: space-between;
    align-items: center;
    gap: 10px;
    margin: 8px 0;
    position: relative;
  }

  .nav-arrow {
    background: transparent;
    color: #333;
    border: 1px solid #ccc;
    border-radius: 3px;
    padding: 8px 12px;
    cursor: pointer;
    font-size: 14px;
    font-weight: bold;
    transition: all 0.2s;
    min-width: 40px;
    display: flex;
    align-items: center;
    justify-content: center;
  }

  .nav-arrow:hover {
    background: #f0f0f0;
    color: #000;
  }

  .nav-arrow:disabled {
    background: transparent;
    color: #ccc;
    border-color: #eee;
    cursor: not-allowed;
  }

  .audio-container {
    flex: 1;
    margin: 0 10px;
  }

  /* Cluster Playlist */
  .cluster-playlist {
    position: absolute;
    background: rgba(255, 255, 255, 0.85);
    border: 1px solid #ccc;
    border-radius: 4px;
    padding: 4px;
    font-size: 11px;
    max-width: 250px;
    max-height: 200px;
    overflow-y: auto;
    z-index: 1000;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
  }

  .cluster-item {
    padding: 4px 8px;
    cursor: pointer;
    border-bottom: 1px solid #eee;
    display: flex;
    align-items: center;
    gap: 4px;
    transition: background-color 0.2s;
    border-radius: 2px;
    margin: 1px 0;
  }

  .cluster-item:hover {
    background-color: rgba(240, 240, 240, 0.9);
  }

  .cluster-item:last-child {
    border-bottom: none;
  }

  .cluster-item-title {
    flex: 1;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
  }

  .cluster-item .play-icon {
    width: 0;
    height: 0;
    border-left: 5px solid #5c3a2e;
    border-top: 3px solid transparent;
    border-bottom: 3px solid transparent;
    flex-shrink: 0;
  }

  .cluster-item:hover .play-icon {
    border-left-color: #4a2e24;
  }

  /* Map Controls */
  .mapboxgl-canvas {
    cursor: grab;
  }

  .mapboxgl-popup {
    z-index: 10 !important;
  }

  .mapboxgl-popup-content {
    opacity: 0.8;
    transition: opacity 0.3s ease;
    min-width: 320px;
    max-width: 90vw;
    box-sizing: border-box;
  }

  .mapboxgl-popup-close-button:focus {
    outline: none;
    box-shadow: none;
  }

  .loading-placeholder {
    text-align: center;
    color: #555;
    padding: 8px;
  }

  /* Notification Messages */
  .notification {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: rgba(0, 0, 0, 0.7);
    color: white;
    padding: 12px 20px;
    border-radius: 6px;
    font-size: 14px;
    z-index: 10000;
    pointer-events: none;
    opacity: 0;
    transition: opacity 0.3s ease;
  }

  .notification.show {
    opacity: 1;
  }

  /* Responsive adjustments */
  @media (max-width: 768px) {
    .playlist-wrapper {
      width: 300px;
    }
    
    .control-panel {
      right: 10px;
      top: 10px;
    }
    
    .mini-infobox {
      max-width: 150px;
    }
  }

  /* Fullscreen styles */
  .fullscreen-active {
    position: fixed !important;
    top: 0 !important;
    left: 0 !important;
    width: 100vw !important;
    height: 100vh !important;
    z-index: 9999 !important;
  }

  /* Hide audio focus outline */
  audio:focus {
    outline: none;
  }
</style>
</head>
<body>
  <div id="map"></div>
  
  <div class="playlist-wrapper" id="playlistWrapper">
    <button class="playlist-toggle" id="playlistToggle" title="Collapse playlist">◀</button>
    <div class="scroll-arrow up" id="scrollUp">▲</div>
    <div class="playlist" id="playlist">
      <div class="loading-placeholder">loading recordings...</div>
    </div>
    <div class="scroll-arrow down" id="scrollDown">▼</div>
  </div>

  <div class="control-panel">
    <div class="control-row">
      <button class="control-btn" id="resetMapBtn">Reset Map</button>
      <button class="control-btn" id="fullscreenBtn">Fullscreen</button>
      <button class="control-btn" id="terrain3dBtn">3D Terrain</button>
    </div>
    <div class="sort-controls">
    <button class="control-btn sort-btn active" id="sortNobo">NOBO ↑</button>
    <button class="control-btn sort-btn" id="sortSobo">SOBO ↓</button>
    <button class="control-btn sort-btn" id="sortDate">STEREO ↻</button>
      <div class="random-control">
        <span class="random-label">Random</span>
        <div class="toggle-switch" id="randomToggle" title="Toggle random playback">
          <div class="toggle-slider"></div>
        </div>
      </div>
    </div>
  </div>

  <div class="notification" id="notification"></div>

  <script src="https://api.mapbox.com/mapbox-gl-js/v2.8.1/mapbox-gl.js"></script>
  <script src="config.js"></script>
  <script>
    // Configuration
    const CONFIG = {
      MAPBOX_TOKEN: window.MAPBOX_CONFIG?.token || 'pk.eyJ1IjoidGhta2x5IiwiYSI6ImNseXVyMjhueDA3YTQybW9mcHJrZGJ3YnEifQ.Nv-LsNg5eKIE6SeOVVJpYg',
      GOOGLE_SCRIPT_URL: 'https://script.google.com/macros/s/AKfycbygcwJ8ms4Zpq1BeGM_jQTEuajvoYw-A5-nkoTMZ5FBPfOP2DyORWfDuET2TEhXarfd/exec',
      DEFAULT_CENTER: [-122.50276, 41.31727],
      getDefaultZoom: () => {
        const screenWidth = window.screen.width;
        const screenHeight = window.screen.height;
        
        // Detect browsers that might report altered screen dimensions
        const isBrave = navigator.brave && navigator.brave.isBrave;
        const isFirefox = navigator.userAgent.toLowerCase().includes('firefox');
        const isTor = navigator.userAgent.toLowerCase().includes('tor');
        
        // Some browsers alter screen dimensions for privacy or have inconsistent reporting
        const hasUnreliableScreenData = isBrave || isTor || 
          (isFirefox && screenWidth === 1366 && screenHeight === 768) || // Firefox often defaults to this
          screenWidth === 1024 || screenHeight === 768; // Common privacy screen sizes
        
        // Calculate diagonal pixel resolution
        const diagonalPixels = Math.sqrt(screenWidth * screenWidth + screenHeight * screenHeight);
        
        // Reference points based on your current preferences:
        // 13" MacBook Air M3: zoom = 4.4
        // 27" monitor: zoom = 4.95
        
        if (hasUnreliableScreenData) {
          // Fallback logic for browsers with unreliable screen data
          // Use viewport dimensions as backup indicator
          const viewportWidth = window.innerWidth;
          const viewportHeight = window.innerHeight;
          const viewportDiagonal = Math.sqrt(viewportWidth * viewportWidth + viewportHeight * viewportHeight);
          
          if (viewportDiagonal > 2800) {
            return 4.2; // Large desktop/high-res
          } else if (viewportDiagonal > 2000) {
            return 4.95; // Desktop equivalent - adjusted threshold for 27" monitors  
          } else if (viewportDiagonal > 1800) {
            return 4.45; // Laptop equivalent - fine-tuned for Brave on 13"
          } else if (viewportDiagonal > 1400) {
            return 4.5; // Standard laptop
          } else {
            return 4.8; // Smaller screens/mobile
          }
        } else {
          // Safari/Chrome and other browsers with reliable screen data
          // Use your exact measurements for interpolation
          const ref1 = { diagonal: 3037, zoom: 4.4 };  // 13" MacBook Air M3 (2560x1664)
          const ref2 = { diagonal: 2203, zoom: 4.95 }; // 27" monitor (1920x1080)
          
          // Calculate zoom using linear interpolation between reference points
          if (diagonalPixels <= ref2.diagonal) {
            // Smaller/lower-res than 27" monitor - extrapolate to higher zoom
            const slope = (ref2.zoom - ref1.zoom) / (ref2.diagonal - ref1.diagonal);
            return Math.min(5.5, ref2.zoom + slope * (ref2.diagonal - diagonalPixels));
          } else if (diagonalPixels >= ref1.diagonal) {
            // Higher-res than MacBook Air - extrapolate to lower zoom  
            const slope = (ref2.zoom - ref1.zoom) / (ref2.diagonal - ref1.diagonal);
            return Math.max(4.0, ref1.zoom + slope * (diagonalPixels - ref1.diagonal));
          } else {
            // Between the two reference points - interpolate
            const ratio = (diagonalPixels - ref2.diagonal) / (ref1.diagonal - ref2.diagonal);
            return ref2.zoom + ratio * (ref1.zoom - ref2.zoom);
          }
        }
      },
      ZOOM_2D: 10,
      ZOOM_3D: 14
    };

    // Notification System
    function showNotification(message, duration = 3000) {
      const notification = document.getElementById('notification');
      notification.textContent = message;
      notification.classList.add('show');
      setTimeout(() => {
        notification.classList.remove('show');
      }, duration);
    }

    // Audio Controller Class
    class AudioController {
      constructor() {
        this.currentAudio = null;
        this.currentIndex = -1;
        this.isPlaying = false;
        this.playMode = 'sequential';
        this.sortMode = 'nobo';
        this.playQueue = [];
        this.lastPlayNext = 0;
        this.playHistory = []; // Track play history for random mode
        this.setupWakeLock();
      }

      async setupWakeLock() {
        if ('wakeLock' in navigator) {
          try {
            this.wakeLock = await navigator.wakeLock.request('screen');
          } catch (err) {
            console.log('Wake lock not supported');
          }
        }
      }

      play(index, audioData) {
        if (this.currentAudio) {
          this.currentAudio.pause();
          this.currentAudio = null;
        }

        const track = audioData[index];
        if (!track) return;

        // Add to play history (keep last 50 for memory management)
        if (this.currentIndex !== -1 && this.currentIndex !== index) {
          this.playHistory.push(this.currentIndex);
          if (this.playHistory.length > 50) {
            this.playHistory.shift();
          }
        }

        this.currentIndex = index;
        this.isPlaying = true;

        const audio = document.createElement('audio');
        audio.src = track.audioUrl;
        audio.preload = 'auto';
        audio.controlsList = 'nodownload';
        audio.oncontextmenu = () => false;
        
        audio.addEventListener('ended', () => {
          this.playNext(audioData);
        });

        audio.addEventListener('error', () => {
          console.warn('Audio failed to load:', track.name, 'URL:', track.audioUrl);
          // Don't auto-play next track on error to prevent infinite loops
          // this.playNext(audioData);
          showNotification(`Audio failed to load: ${track.name}`, 3000);
        });

        this.currentAudio = audio;
        return audio;
      }

      togglePlayPause() {
        if (!this.currentAudio) return;
        
        if (this.currentAudio.paused) {
          this.currentAudio.play();
          this.isPlaying = true;
        } else {
          this.currentAudio.pause();
          this.isPlaying = false;
        }
      }

      playNext(audioData) {
        // Circuit breaker: prevent rapid successive calls
        const now = Date.now();
        if (this.lastPlayNext && (now - this.lastPlayNext) < 1000) {
          console.warn('PlayNext called too quickly, blocking to prevent loop');
          return;
        }
        this.lastPlayNext = now;

        let nextIndex;
        
        if (this.playMode === 'random') {
          nextIndex = Math.floor(Math.random() * audioData.length);
        } else {
          // Navigation based on sort mode:
          if (this.sortMode === 'sobo') {
            // SOBO: next goes down the list (towards Mexico/higher index)
            nextIndex = this.currentIndex + 1;
            if (nextIndex >= audioData.length) {
              nextIndex = 0; // Wrap to top (Canada)
            }
          } else if (this.sortMode === 'date') {
            // STEREO: next goes down chronologically (towards newer/higher index)
            nextIndex = this.currentIndex + 1;
            if (nextIndex >= audioData.length) {
              nextIndex = 0; // Wrap to beginning (earliest)
            }
          } else { // nobo mode
            // NOBO: next goes up the list (towards Canada/lower index)
            nextIndex = this.currentIndex - 1;
            if (nextIndex < 0) {
              nextIndex = audioData.length - 1; // Wrap to bottom (Mexico)
            }
          }
        }
        
        if (nextIndex !== this.currentIndex) {
          mapController.playAudio(nextIndex);
        }
      }

      playPrevious(audioData) {
        let prevIndex;
        
        if (this.playMode === 'random') {
          // In random mode, only go back if there's history
          if (this.playHistory.length === 0) {
            return; // Do nothing if no history
          }
          prevIndex = this.playHistory.pop();
        } else {
          // Navigation based on sort mode:
          if (this.sortMode === 'sobo') {
            // SOBO: prev goes up the list (towards Canada/lower index)
            prevIndex = this.currentIndex - 1;
            if (prevIndex < 0) {
              prevIndex = audioData.length - 1; // Wrap to bottom (Mexico)
            }
          } else if (this.sortMode === 'date') {
            // STEREO: prev goes up chronologically (towards older/lower index)
            prevIndex = this.currentIndex - 1;
            if (prevIndex < 0) {
              prevIndex = audioData.length - 1; // Wrap to end (latest)
            }
          } else { // nobo mode
            // NOBO: prev goes down the list (towards Mexico/higher index)
            prevIndex = this.currentIndex + 1;
            if (prevIndex >= audioData.length) {
              prevIndex = 0; // Wrap to top (Canada)
            }
          }
        }
        
        mapController.playAudio(prevIndex);
      }

      stop() {
        if (this.currentAudio) {
          this.currentAudio.pause();
          this.currentAudio = null;
        }
        this.isPlaying = false;
        this.currentIndex = -1;
      }
    }

    // UI Controller Class
    class UIController {
      constructor() {
        this.playlistExpanded = true;
        this.isFullscreen = false;
        this.is3DEnabled = false;
        this.miniInfoBoxes = [];
        this.clusterPlaylist = null;
        this.setupEventListeners();
      }

      setupEventListeners() {
        // Playlist toggle
        document.getElementById('playlistToggle').addEventListener('click', () => {
          this.togglePlaylist();
        });

        // Sort buttons
        document.querySelectorAll('.sort-btn').forEach(btn => {
          btn.addEventListener('click', (e) => {
            this.handleSortChange(e.target.id);
          });
        });

        // Random toggle
        document.getElementById('randomToggle').addEventListener('click', () => {
          audioController.playMode = audioController.playMode === 'random' ? 'sequential' : 'random';
          this.updateRandomToggle();
        });

        document.getElementById('resetMapBtn').addEventListener('click', () => {
          mapController.resetMap();
        });

        document.getElementById('fullscreenBtn').addEventListener('click', () => {
          this.toggleFullscreen();
        });

        document.getElementById('terrain3dBtn').addEventListener('click', () => {
          this.toggle3D();
        });

        // Global spacebar handler - prevent focus on audio elements
        document.addEventListener('keydown', (e) => {
          if (e.code === 'Space' && audioController.currentAudio) {
            e.preventDefault();
            audioController.togglePlayPause();
            // Blur any focused audio elements
            if (document.activeElement.tagName === 'AUDIO') {
              document.activeElement.blur();
            }
          }
        });

        // Scroll arrows
        const playlist = document.getElementById('playlist');
        const scrollUp = document.getElementById('scrollUp');
        const scrollDown = document.getElementById('scrollDown');

        playlist.addEventListener('scroll', () => this.updateScrollArrows());
        scrollUp.addEventListener('click', () => playlist.scrollBy({ top: -100, behavior: 'smooth' }));
        scrollDown.addEventListener('click', () => playlist.scrollBy({ top: 100, behavior: 'smooth' }));

        this.setupPlaylistDrag();
      }

      togglePlaylist() {
        const wrapper = document.getElementById('playlistWrapper');
        const toggle = document.getElementById('playlistToggle');
        
        this.playlistExpanded = !this.playlistExpanded;
        
        if (this.playlistExpanded) {
          wrapper.classList.remove('collapsed');
          toggle.textContent = '◀';
          toggle.title = 'Collapse playlist';
        } else {
          wrapper.classList.add('collapsed');
          toggle.textContent = '▶';
          toggle.title = 'Expand playlist';
        }
      }

      handleSortChange(sortId) {
        document.querySelectorAll('.sort-btn').forEach(btn => btn.classList.remove('active'));
        document.getElementById(sortId).classList.add('active');

        const sortMap = {
          'sortNobo': 'nobo',
          'sortSobo': 'sobo',
          'sortDate': 'date'
        };
        
        audioController.sortMode = sortMap[sortId];
        mapController.sortAndUpdatePlaylist();
      }

      updateRandomToggle() {
        const toggle = document.getElementById('randomToggle');
        toggle.classList.toggle('active', audioController.playMode === 'random');
      }

      toggleFullscreen() {
        const body = document.body;
        
        if (!this.isFullscreen) {
          if (body.requestFullscreen) {
            body.requestFullscreen();
          } else if (body.webkitRequestFullscreen) {
            body.webkitRequestFullscreen();
          } else if (body.msRequestFullscreen) {
            body.msRequestFullscreen();
          }
        } else {
          if (document.exitFullscreen) {
            document.exitFullscreen();
          } else if (document.webkitExitFullscreen) {
            document.webkitExitFullscreen();
          } else if (document.msExitFullscreen) {
            document.msExitFullscreen();
          }
        }
      }

      toggle3D() {
        this.is3DEnabled = !this.is3DEnabled;
        const btn = document.getElementById('terrain3dBtn');
        btn.classList.toggle('active', this.is3DEnabled);

        if (this.is3DEnabled) {
          // Add 3D terrain source first
          if (!map.getSource('mapbox-dem')) {
            map.addSource('mapbox-dem', {
              'type': 'raster-dem',
              'url': 'mapbox://mapbox.mapbox-terrain-dem-v1',
              'tileSize': 512,
              'maxzoom': 14
            });
          }
          
          // Set terrain and wait for it to load
          map.setTerrain({ 'source': 'mapbox-dem', 'exaggeration': 1.5 });
          
          // Wait for terrain to be ready, then apply 3D positioning
          const apply3DView = () => {
            if (audioController.currentIndex >= 0) {
              const currentTrack = mapController.audioData[audioController.currentIndex];
              if (currentTrack) {
                // Position for 3D view of current track
                const coords = [parseFloat(currentTrack.lng), parseFloat(currentTrack.lat)];
                map.flyTo({
                  center: coords,
                  zoom: CONFIG.ZOOM_3D,
                  pitch: 75,
                  bearing: 0,
                  duration: 2500,
                  easing: t => 1 - Math.pow(1 - t, 3)
                });
              } else {
                // No valid track, just enable 3D at current location
                map.flyTo({
                  pitch: 75,
                  zoom: Math.max(map.getZoom(), CONFIG.ZOOM_3D),
                  duration: 2000
                });
              }
            } else {
              // No active track, just enable 3D at current location
              map.flyTo({
                pitch: 75,
                zoom: Math.max(map.getZoom(), CONFIG.ZOOM_3D),
                duration: 2000
              });
            }
            showNotification('3D view enabled - Hold Ctrl + drag to rotate', 4000);
          };
          
          // Wait a moment for terrain to initialize, then apply 3D view
          setTimeout(apply3DView, 300);
          
        } else {
          // Disable 3D
          map.setTerrain(null);
          map.flyTo({
            pitch: 0,
            duration: 1500
          });
          
          // Clean up terrain source
          setTimeout(() => {
            if (map.getSource('mapbox-dem')) {
              map.removeSource('mapbox-dem');
            }
          }, 1600);
          
          showNotification('3D view disabled', 2000);
        }
      }

      updateScrollArrows() {
        const playlist = document.getElementById('playlist');
        const scrollUp = document.getElementById('scrollUp');
        const scrollDown = document.getElementById('scrollDown');
        
        scrollUp.style.display = playlist.scrollTop > 0 ? 'block' : 'none';
        scrollDown.style.display = (playlist.scrollTop + playlist.clientHeight) < playlist.scrollHeight ? 'block' : 'none';
      }

      setupPlaylistDrag() {
        const playlist = document.getElementById('playlist');
        let dragging = false, startY, scrollStart, vel = 0, lastY = 0, lastTime = 0, raf;
        let dragStarted = false, preventClick = false;

        playlist.addEventListener('mousedown', e => {
          dragging = true;
          dragStarted = false;
          playlist.classList.add('dragging');
          startY = e.pageY;
          scrollStart = playlist.scrollTop;
          vel = 0;
          lastY = e.pageY;
          lastTime = Date.now();
          if (raf) cancelAnimationFrame(raf);
        });

        playlist.addEventListener('mousemove', e => {
          if (!dragging) return;
          e.preventDefault();
          const now = Date.now();
          const dy = e.pageY - lastY;
          const dt = now - lastTime;
          if (dt > 0) vel = dy / dt * 16;
          playlist.scrollTop = scrollStart - (e.pageY - startY);
          lastY = e.pageY;
          lastTime = now;
          this.updateScrollArrows();

          if (!dragStarted && Math.abs(e.pageY - startY) > 5) {
            dragStarted = true;
            preventClick = true;
          }
        });

        ['mouseup', 'mouseleave'].forEach(ev => {
          playlist.addEventListener(ev, () => {
            if (!dragging) return;
            dragging = false;
            playlist.classList.remove('dragging');
            
            const momentum = () => {
              if (Math.abs(vel) < 0.5) return;
              playlist.scrollTop -= vel;
              vel *= 0.95;
              raf = requestAnimationFrame(momentum);
              this.updateScrollArrows();
            };
            momentum();

            if (preventClick) {
              setTimeout(() => { preventClick = false; }, 100);
            }
          });
        });

        playlist.addEventListener('click', e => {
          if (preventClick) {
            e.preventDefault();
            e.stopPropagation();
          }
        }, true);
      }

      showMiniInfoBoxes(currentTrack, audioData) {
        this.clearMiniInfoBoxes();

        const visiblePoints = map.queryRenderedFeatures({ layers: ['unclustered-point'] });
        
        visiblePoints.forEach(point => {
          const originalIndex = parseInt(point.properties.originalIndex);
          
          // Find this track in current sorted data
          const currentIndex = audioData.findIndex(track => track.originalIndex === originalIndex);
          if (currentIndex === -1) return;
          
          // Skip the currently playing track - it has the main popup
          if (currentIndex === audioController.currentIndex) return;
          
          const track = audioData[currentIndex];
          if (!track) return;

          const coords = point.geometry.coordinates;
          const pixelCoords = map.project(coords);
          
          const infoBox = document.createElement('div');
          infoBox.className = 'mini-infobox';
          infoBox.dataset.trackIndex = currentIndex; // Store current playlist index
          
          const playIcon = document.createElement('div');
          playIcon.className = 'play-icon';
          
          const title = document.createElement('span');
          title.className = 'mini-infobox-title';
          title.textContent = track.name.replace(/^[^\s]+\s+-\s+/, '');
          
          // Make entire mini box clickable to play audio and show popup
          infoBox.addEventListener('click', (e) => {
            e.stopPropagation();
            mapController.playAudio(currentIndex);
          });
          
          infoBox.appendChild(playIcon);
          infoBox.appendChild(title);
          
          // Auto-size based on content
          document.body.appendChild(infoBox);
          const textWidth = title.scrollWidth;
          infoBox.style.maxWidth = Math.min(Math.max(textWidth + 50, 120), 250) + 'px';
          document.body.removeChild(infoBox);
          
          infoBox.style.left = `${pixelCoords.x + 10}px`;
          infoBox.style.top = `${pixelCoords.y - 20}px`;
          
          map.getContainer().appendChild(infoBox);
          this.miniInfoBoxes.push(infoBox);
        });
      }

      updateMiniInfoBoxPositions() {
        // Update positions of existing mini info boxes to follow their geographic points
        this.miniInfoBoxes.forEach(infoBox => {
          const trackIndex = parseInt(infoBox.dataset.trackIndex);
          const track = mapController.audioData[trackIndex];
          if (track) {
            const coords = [parseFloat(track.lng), parseFloat(track.lat)];
            const pixelCoords = map.project(coords);
            infoBox.style.left = `${pixelCoords.x + 10}px`;
            infoBox.style.top = `${pixelCoords.y - 20}px`;
          }
        });
      }

      clearMiniInfoBoxes() {
        this.miniInfoBoxes.forEach(box => {
          if (box.parentNode) {
            box.parentNode.removeChild(box);
          }
        });
        this.miniInfoBoxes = [];
      }

      showClusterPlaylist(e, leaves) {
        this.hideClusterPlaylist();

        const playlist = document.createElement('div');
        playlist.className = 'cluster-playlist';
        
        leaves.forEach(leaf => {
          const item = document.createElement('div');
          item.className = 'cluster-item';
          
          const playIcon = document.createElement('div');
          playIcon.className = 'play-icon';
          
          const title = document.createElement('span');
          title.className = 'cluster-item-title';
          title.textContent = leaf.properties.name.replace(/^[^\s]+\s+-\s+/, '');
          
          item.appendChild(playIcon);
          item.appendChild(title);
          
          item.addEventListener('click', () => {
            mapController.playAudio(parseInt(leaf.properties.id));
            this.hideClusterPlaylist();
          });
          
          item.addEventListener('mouseleave', () => {
            // Small delay to allow moving between items
            setTimeout(() => {
              if (!playlist.matches(':hover')) {
                this.hideClusterPlaylist();
              }
            }, 100);
          });
          
          playlist.appendChild(item);
        });

        // Position the playlist
        playlist.style.left = `${e.point.x + 10}px`;
        playlist.style.top = `${e.point.y - 10}px`;
        
        // Handle playlist mouse leave
        playlist.addEventListener('mouseleave', () => {
          this.hideClusterPlaylist();
        });
        
        map.getContainer().appendChild(playlist);
        this.clusterPlaylist = playlist;
      }

      hideClusterPlaylist() {
        if (this.clusterPlaylist) {
          this.clusterPlaylist.remove();
          this.clusterPlaylist = null;
        }
      }
    }

    // Map Controller Class
    class MapController {
      constructor() {
        this.audioData = [];
        this.originalAudioData = []; // Keep original order for stable map references
        this.currentPopup = null;
        this.isPositioning = false;
        this.animationTimeout = null;
        this.moveTimeout = null;
        this.setupMap();
      }

      // Helper function to get display mile based on sort mode
      getDisplayMile(track) {
        // Don't display mile if it's a placeholder (starts with ~)
        if (track.mile && track.mile.toString().startsWith('~')) {
          return null;
        }
        
        if (audioController.sortMode === 'sobo' && track.mile && track.mile.toString().trim().toLowerCase() !== 'n/a') {
          const nobobMile = parseFloat(track.mile);
          if (!isNaN(nobobMile)) {
            const soboMile = 2655.8 - nobobMile;
            return soboMile.toFixed(1);
          }
        }
        return track.mile;
      }

      // Helper function to get numeric mile value for sorting (handles ~ placeholders)
      getMileForSorting(track) {
        if (!track.mile || track.mile.toString().trim().toLowerCase() === 'n/a') {
          return null;
        }
        
        const mileStr = track.mile.toString();
        if (mileStr.startsWith('~')) {
          // Placeholder mile - remove ~ and parse
          return parseFloat(mileStr.substring(1));
        }
        
        return parseFloat(mileStr);
      }

      setupMap() {
        mapboxgl.accessToken = CONFIG.MAPBOX_TOKEN;
        
        window.map = new mapboxgl.Map({
          container: 'map',
          style: 'mapbox://styles/thmkly/clyup637d004201ri2tkpaywq',
          center: CONFIG.DEFAULT_CENTER,
          zoom: CONFIG.getDefaultZoom()
        });

        map.on('load', () => {
          this.setupMapLayers();
          this.setupMapEvents();
          this.loadAudioData();
        });
      }

      setupMapLayers() {
        map.addSource('audio', {
          type: 'geojson',
          data: { type: 'FeatureCollection', features: [] },
          cluster: true,
          clusterMaxZoom: 14,
          clusterRadius: 45
        });

        map.addLayer({
          id: 'clusters',
          type: 'circle',
          source: 'audio',
          filter: ['has', 'point_count'],
          paint: {
            'circle-color': '#51bbd6',
            'circle-opacity': 0.7,
            'circle-stroke-width': 1,
            'circle-stroke-color': '#197991',
            'circle-stroke-opacity': 0.75,
            'circle-radius': [
              'step',
              ['get', 'point_count'],
              18, 3, 22, 5, 26, 6, 30, 7, 34, 8, 36,
              10, 38, 15, 40, 18, 42, 22, 44, 25, 46,
              30, 48, 35, 50, 40, 52, 50, 54, 100, 56
            ]
          }
        });

        map.addLayer({
          id: 'cluster-count',
          type: 'symbol',
          source: 'audio',
          filter: ['has', 'point_count'],
          layout: {
            'text-field': '{point_count_abbreviated}',
            'text-font': ['Open Sans Semibold', 'Arial Unicode MS Bold'],
            'text-size': 12
          }
        });

        map.addLayer({
          id: 'unclustered-point',
          type: 'circle',
          source: 'audio',
          filter: ['!', ['has', 'point_count']],
          paint: {
            'circle-color': '#5c3a2e',
            'circle-radius': 6,
            'circle-opacity': 0.6,
            'circle-stroke-width': 1,
            'circle-stroke-color': '#fff',
            'circle-stroke-opacity': 0.8
          }
        });
      }

      setupMapEvents() {
        ['clusters', 'unclustered-point'].forEach(layer => {
          map.on('mouseenter', layer, () => map.getCanvas().style.cursor = 'pointer');
          map.on('mouseleave', layer, () => map.getCanvas().style.cursor = '');
        });

        map.on('click', 'clusters', (e) => {
          const features = map.queryRenderedFeatures(e.point, { layers: ['clusters'] });
          if (!features.length) return;
          
          const clusterId = features[0].properties.cluster_id;
          map.getSource('audio').getClusterExpansionZoom(clusterId, (err, zoom) => {
            if (err) return;
            map.getSource('audio').getClusterLeaves(clusterId, 100, 0, (_, leaves) => {
              const bounds = new mapboxgl.LngLatBounds();
              leaves.forEach(leaf => bounds.extend(leaf.geometry.coordinates));
              map.fitBounds(bounds, { 
                padding: { top: 50, bottom: 50, left: this.getLeftPadding(), right: 20 } 
              });
            });
          });
        });

        map.on('mouseenter', 'clusters', (e) => {
          // Cluster hover playlist removed - redundant with main playlist and mini info boxes
        });

        map.on('mouseleave', 'clusters', () => {
          // Cluster hover playlist removed
        });

        map.on('click', 'unclustered-point', (e) => {
          const feature = e.features[0];
          if (!feature) return;
          const originalIndex = parseInt(feature.properties.originalIndex);
          
          // Find this track in the current sorted playlist
          const currentIndex = this.audioData.findIndex(track => track.originalIndex === originalIndex);
          if (currentIndex !== -1) {
            this.playAudio(currentIndex);
          }
        });

        map.on('move', () => {
          // Update mini box positions in real-time during movement
          uiController.updateMiniInfoBoxPositions();
        });

        map.on('moveend', () => {
          // Refresh mini boxes when movement is completely finished
          if (!this.isPositioning) {
            const visiblePoints = map.queryRenderedFeatures({ layers: ['unclustered-point'] });
            if (visiblePoints.length > 0 && visiblePoints.length < 50) {
              uiController.showMiniInfoBoxes(null, this.audioData);
            }
          }
        });

        document.addEventListener('fullscreenchange', () => {
          uiController.isFullscreen = !!document.fullscreenElement;
          const btn = document.getElementById('fullscreenBtn');
          btn.textContent = uiController.isFullscreen ? 'Exit Fullscreen' : 'Fullscreen';
          btn.classList.toggle('active', uiController.isFullscreen);
          
          if (uiController.isFullscreen) {
            // Removed redundant fullscreen message - browsers show native notification
          }
        });
      }

      getLeftPadding() {
        return uiController.playlistExpanded ? 370 : 20;
      }

      loadAudioData() {
        const url = `${CONFIG.GOOGLE_SCRIPT_URL}?nocache=${Date.now()}`;
        console.log('Fetching data from:', url);
        
        fetch(url)
          .then(response => {
            console.log('Response status:', response.status);
            console.log('Response headers:', response.headers);
            return response.text();
          })
          .then(text => {
            console.log('Raw response:', text);
            try {
              const data = JSON.parse(text);
              console.log('Parsed data:', data);
              console.log('Data length:', data.length);
              
              if (data.error) {
                throw new Error(data.error);
              }
              
              if (data.length === 0) {
                throw new Error('No recordings found');
              }
              
              // Log first item to check structure
              if (data.length > 0) {
                console.log('First item structure:', data[0]);
                console.log('First item audioUrl:', data[0].audioUrl);
              }
              
              // Add original index to each track for stable map references
              this.originalAudioData = data.map((track, index) => ({
                ...track,
                originalIndex: index
              }));
              
              // Set up data in fixed geographic order (Canada at top for display)
              this.audioData = this.sortByMileAndDate([...this.originalAudioData], 'nobo');
              this.sortAndUpdatePlaylist();
              this.updateMapData();
              
              showNotification(`Loaded ${data.length} recordings`, 2000);
            } catch (parseError) {
              console.error('JSON Parse Error:', parseError);
              throw new Error(`Invalid JSON response: ${parseError.message}`);
            }
          })
          .catch(e => {
            console.error('Load Error:', e);
            const errorMsg = e.message || 'Unknown error occurred';
            document.getElementById('playlist').innerHTML = `<p class="loading-placeholder">Failed to load recordings: ${errorMsg}</p>`;
            showNotification(`Error: ${errorMsg}`, 5000);
          });
      }

      sortAndUpdatePlaylist() {
        // Remember currently playing track
        const currentlyPlayingTrack = audioController.currentIndex >= 0 ? 
          this.audioData[audioController.currentIndex] : null;
        
        // For STEREO mode, actually reorder the playlist chronologically
        // For NOBO/SOBO modes, keep static geographic order and only update display
        if (audioController.sortMode === 'date') {
          // STEREO: Reorder playlist chronologically
          this.audioData = this.sortByMileAndDate([...this.originalAudioData], 'date');
          
          // Update current index to match new chronological order
          if (currentlyPlayingTrack) {
            audioController.currentIndex = this.audioData.findIndex(track => 
              track.originalIndex === currentlyPlayingTrack.originalIndex
            );
          }
        }
        
        // Update playlist display
        this.updatePlaylistOnly();
        
        // Restore the active track highlighting after playlist update
        if (currentlyPlayingTrack) {
          this.updateActiveTrack(audioController.currentIndex);
        }
        
        // Set scroll position based on sort mode
        this.setPlaylistScrollPosition();
        
        // Update popup if one is open to show correct mileage
        if (this.currentPopup && currentlyPlayingTrack) {
          this.refreshPopupMileage(currentlyPlayingTrack);
        }
      }

      sortByMileAndDate(data, mode = 'nobo') {
        if (mode === 'date') {
          // STEREO mode: sort everything by timestamp
          return [...data].sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));
        }
        
        // For NOBO/SOBO: purely spatial sorting by mile (including ~ placeholders)
        const tracksWithMiles = data.filter(track => {
          const mile = this.getMileForSorting(track);
          return mile !== null && !isNaN(mile);
        });
        
        const tracksWithoutMiles = data.filter(track => {
          const mile = this.getMileForSorting(track);
          return mile === null || isNaN(mile);
        });

        // Sort tracks with miles (including placeholders) by mile number
        // NOBO: ascending (0 → 2655), SOBO: descending (2655 → 0)
        const ascending = mode === 'nobo';
        tracksWithMiles.sort((a, b) => {
          const mileA = this.getMileForSorting(a);
          const mileB = this.getMileForSorting(b);
          if (Math.abs(mileA - mileB) < 0.01) { // Same mile (accounting for decimals)
            // If same mile, sort by timestamp
            return new Date(a.timestamp) - new Date(b.timestamp);
          }
          return ascending ? mileA - mileB : mileB - mileA;
        });

        // For display: reverse the order so Canada appears at top
        // NOBO sorted (0→2655) becomes display (2655→0)
        // SOBO sorted (2655→0) stays as (2655→0)
        if (mode === 'nobo') {
          tracksWithMiles.reverse();
        }

        // Sort tracks without miles by timestamp
        tracksWithoutMiles.sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));

        // Combine: mile-sorted tracks first, then timestamp-sorted tracks without miles
        return [...tracksWithMiles, ...tracksWithoutMiles];
      }

      updateMapData() {
        const source = map.getSource('audio');
        if (!source) return;
        
        // Use original data for map - points stay static regardless of sort order
        const geojson = {
          type: 'FeatureCollection',
          features: this.originalAudioData.map((track, index) => ({
            type: 'Feature',
            geometry: { 
              type: 'Point', 
              coordinates: [parseFloat(track.lng), parseFloat(track.lat)] 
            },
            properties: { 
              ...track, 
              originalIndex: index, // Use original index for stable reference
              mile: track.mile || 'N/A'
            }
          }))
        };
        
        source.setData(geojson);
      }

      updatePlaylistOnly() {
        const playlist = document.getElementById('playlist');
        playlist.innerHTML = '';
        
        this.audioData.forEach((track, index) => {
          const div = document.createElement('div');
          div.className = 'track';
          div.dataset.id = index;
          
          const trackInfo = document.createElement('div');
          trackInfo.className = 'track-info';
          trackInfo.textContent = track.name.replace(/^[^\s]+\s+-\s+/, '');
          
          const trackMile = document.createElement('div');
          trackMile.className = 'track-mile';
          const displayMile = this.getDisplayMile(track);
          const mile = displayMile !== null && displayMile.toString().trim().toLowerCase() !== 'n/a' ? `mi.${displayMile}` : '';
          trackMile.textContent = mile;
          
          div.appendChild(trackInfo);
          div.appendChild(trackMile);
          
          div.addEventListener('click', (e) => {
            this.playAudio(index);
          });
          
          playlist.appendChild(div);
        });
        
        // Show collapse arrow now that playlist is rendered
        const toggleBtn = document.getElementById('playlistToggle');
        toggleBtn.classList.add('visible');
        
        uiController.updateScrollArrows();
        
        // Force scroll position update on initial load
        if (audioController.currentIndex === -1) {
          setTimeout(() => {
            if (audioController.sortMode === 'sobo') {
              playlist.scrollTop = 0;
            } else if (audioController.sortMode === 'date') {
              playlist.scrollTop = 0;
            } else {
              playlist.scrollTop = playlist.scrollHeight;
            }
          }, 150);
        }
      }

      setPlaylistScrollPosition() {
        const playlist = document.getElementById('playlist');
        
        // Set scroll position based on mode, but only if no track is currently playing
        if (audioController.currentIndex === -1) {
          setTimeout(() => {
            if (audioController.sortMode === 'sobo') {
              // SOBO: Scroll to top (starting at Canada/north)
              playlist.scrollTop = 0;
            } else if (audioController.sortMode === 'date') {
              // STEREO: Scroll to top (starting with earliest recordings)
              playlist.scrollTop = 0;
            } else {
              // NOBO: Scroll to bottom (starting at Mexico/south)
              playlist.scrollTop = playlist.scrollHeight;
            }
          }, 100); // Increased delay to ensure rendering is complete
        }
      }

      playAudio(index) {
        console.log('playAudio called with index:', index);
        
        const track = this.audioData[index];
        if (!track) {
          console.error('No track found at index:', index);
          return;
        }

        console.log('Playing track:', track.name);

        // Stop any runaway animations
        if (this.animationTimeout) {
          clearTimeout(this.animationTimeout);
        }

        this.updateActiveTrack(index);
        const audio = audioController.play(index, this.audioData);
        
        // Clear old mini boxes before positioning
        uiController.clearMiniInfoBoxes();
        
        // Add delay before positioning to prevent conflicts
        this.animationTimeout = setTimeout(() => {
          this.positionMapForTrack(track, index);
          this.showPopup([parseFloat(track.lng), parseFloat(track.lat)], track, audio, index);
          
          // Show mini boxes after map positioning is complete
          const duration = this.getMovementDuration(track);
          setTimeout(() => {
            uiController.showMiniInfoBoxes(null, this.audioData);
          }, duration + 300);
        }, 100);
      }

      showTrackPopup(index, autoPlay = true) {
        const track = this.audioData[index];
        if (!track) return;

        const coords = [parseFloat(track.lng), parseFloat(track.lat)];
        
        if (autoPlay) {
          this.playAudio(index);
        } else {
          this.positionMapForTrack(track, index);
          this.showPopup(coords, track, null, index);
        }
      }

      updateActiveTrack(index) {
        document.querySelectorAll('.track').forEach(el => el.classList.remove('active-track'));
        const activeTrack = document.querySelector(`.track[data-id="${index}"]`);
        if (activeTrack) {
          activeTrack.classList.add('active-track');
          // Smoother, slower scroll to center the track
          activeTrack.scrollIntoView({ 
            behavior: 'smooth', 
            block: 'center',
            inline: 'nearest'
          });
        }
      }

      positionMapForTrack(track, index) {
        console.log('positionMapForTrack called for:', track.name);
        
        // Prevent multiple simultaneous map movements
        if (this.isPositioning) {
          console.log('Already positioning, skipping...');
          return;
        }
        this.isPositioning = true;

        const coords = [parseFloat(track.lng), parseFloat(track.lat)];
        
        const resetPositioning = () => {
          this.isPositioning = false;
        };

        // Calculate distance for duration scaling
        const currentCenter = map.getCenter();
        const distance = this.calculateDistance(
          currentCenter.lat, currentCenter.lng,
          coords[1], coords[0]
        );
        
        // Distance-based duration: longer for farther points
        const distanceKm = distance / 1000;
        let duration;
        if (distanceKm < 5) {
          duration = 2200; // Close points: normal speed
        } else if (distanceKm < 50) {
          duration = 2200 + ((distanceKm - 5) / 45) * 1800; // Medium: 2.2-4s
        } else {
          duration = Math.min(5000, 4000 + ((distanceKm - 50) / 100) * 1000); // Far: 4-5s max
        }

        // Smooth easing with pronounced landing deceleration
        const smoothLandingEasing = (t) => {
          if (t < 0.3) {
            // Gentle acceleration (30% of time)
            return 2 * t * t;
          } else if (t < 0.7) {
            // Steady cruise (40% of time)
            const localT = (t - 0.3) / 0.4;
            return 0.18 + 0.64 * localT; // Linear middle section
          } else {
            // Slow landing approach (30% of time)
            const localT = (t - 0.7) / 0.3;
            return 0.82 + 0.18 * (1 - Math.pow(1 - localT, 3));
          }
        };

        // Check if we're in 3D mode
        const is3D = uiController.is3DEnabled;
        const targetZoom = is3D ? CONFIG.ZOOM_3D : CONFIG.ZOOM_2D;

        const flyToOptions = {
          center: coords,
          zoom: targetZoom,
          duration,
          easing: smoothLandingEasing
        };
        
        // Add 3D properties for smoother rainbow arc
        if (is3D) {
          flyToOptions.pitch = 75;
          flyToOptions.bearing = map.getBearing();
          // Higher curve for ultra-smooth rainbow effect in 3D
          flyToOptions.curve = 2.5; // Even higher curve = smoother, more elevated arc
        }
        
        map.flyTo(flyToOptions);
        setTimeout(resetPositioning, duration + 200);
      }

      calculateDistance(lat1, lng1, lat2, lng2) {
        const R = 6371e3;
        const toRad = deg => deg * Math.PI / 180;
        const dLat = toRad(lat2 - lat1);
        const dLng = toRad(lng2 - lng1);
        const a = Math.sin(dLat / 2) ** 2 +
                  Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) * Math.sin(dLng / 2) ** 2;
        return 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)) * R;
      }

      showPopup(coords, track, audio, index) {
        if (this.currentPopup) {
          this.currentPopup.remove();
        }

        const container = document.createElement('div');
        container.style.fontFamily = 'helvetica, sans-serif';
        container.style.padding = '2px';

        const title = document.createElement('h3');
        title.textContent = track.name;
        title.style.margin = '0 0 4px 0';
        container.appendChild(title);

        const timestamp = document.createElement('p');
        timestamp.style.margin = '0';
        timestamp.style.fontSize = '0.9em';
        timestamp.style.color = '#555';
        timestamp.innerHTML = `<strong>${this.formatTimestamp(track.timestamp)}</strong>`;
        container.appendChild(timestamp);

        if (track.mile && track.mile.toString().trim().toLowerCase() !== 'n/a') {
          const displayMile = this.getDisplayMile(track);
          if (displayMile !== null) {
            const mile = document.createElement('p');
            mile.className = 'popup-mile';
            mile.style.margin = '0';
            mile.style.fontSize = '0.9em';
            mile.style.color = '#555';
            mile.innerHTML = `<strong>mi.${displayMile}</strong>`;
            container.appendChild(mile);
          }
        }

        if (track.notes?.trim()) {
          const notes = document.createElement('p');
          notes.style.margin = '4px 0';
          notes.style.fontSize = '0.9em';
          notes.textContent = track.notes;
          container.appendChild(notes);
        }

        const controls = document.createElement('div');
        controls.className = 'popup-controls';
        
        const prevBtn = document.createElement('button');
        prevBtn.className = 'nav-arrow';
        prevBtn.innerHTML = '&laquo;';
        prevBtn.title = 'Previous';
        
        // Disable previous button logic based on mode and history
        if (audioController.playMode === 'random') {
          prevBtn.disabled = audioController.playHistory.length === 0;
        } else {
          prevBtn.disabled = index === 0;
        }
        
        prevBtn.addEventListener('click', () => {
          audioController.playPrevious(this.audioData);
        });
        
        const nextBtn = document.createElement('button');
        nextBtn.className = 'nav-arrow';
        nextBtn.innerHTML = '&raquo;';
        nextBtn.title = 'Next';
        nextBtn.disabled = index === this.audioData.length - 1;
        nextBtn.addEventListener('click', () => {
          audioController.playNext(this.audioData);
        });
        
        controls.appendChild(prevBtn);
        
        if (audio) {
          const audioContainer = document.createElement('div');
          audioContainer.className = 'audio-container';
          
          // Ensure audio controls always render properly
          audio.controls = true;
          audio.autoplay = true;
          audio.style.width = '100%';
          audio.controlsList = 'nodownload';
          audio.oncontextmenu = () => false;
          
          // Force audio element to load controls
          audio.load();
          
          // Fallback: if controls don't appear, try recreating
          setTimeout(() => {
            if (!audio.controls || audio.offsetHeight === 0) {
              console.warn('Audio controls not rendering, attempting fix...');
              audio.controls = true;
              audio.style.display = 'block';
              audio.style.visibility = 'visible';
            }
          }, 100);
          
          audioContainer.appendChild(audio);
          controls.appendChild(audioContainer);
        }
        
        controls.appendChild(nextBtn);
        container.appendChild(controls);

        const popup = new mapboxgl.Popup({ 
          offset: 25,
          closeOnClick: false,
          closeOnMove: false,
          maxWidth: '400px'
        })
          .setLngLat(coords)
          .setDOMContent(container)
          .addTo(map);

        this.currentPopup = popup;
      }

      refreshPopupMileage(track) {
        if (!this.currentPopup) return;
        
        const popupContent = this.currentPopup._content;
        const mileElement = popupContent.querySelector('.popup-mile');
        if (mileElement && track.mile && track.mile.toString().trim().toLowerCase() !== 'n/a') {
          const displayMile = this.getDisplayMile(track);
          mileElement.innerHTML = `<strong>mi.${displayMile}</strong>`;
        }
      }

      formatTimestamp(timestamp) {
        const date = new Date(timestamp);
        if (isNaN(date)) return timestamp;
        
        const options = {
          timeZone: 'America/Los_Angeles',
          year: 'numeric',
          month: '2-digit',
          day: '2-digit',
          hour: '2-digit',
          minute: '2-digit',
          hour12: false
        };
        
        const parts = new Intl.DateTimeFormat('en-CA', options).formatToParts(date);
        const get = type => parts.find(p => p.type === type)?.value;
        return `${get('year')}-${get('month')}-${get('day')} ${get('hour')}:${get('minute')} PDT`;
      }

      resetMap() {
        audioController.stop();
        uiController.clearMiniInfoBoxes();
        if (this.currentPopup) {
          this.currentPopup.remove();
          this.currentPopup = null;
        }
        
        // Disable 3D mode if it's enabled
        if (uiController.is3DEnabled) {
          uiController.is3DEnabled = false;
          const btn = document.getElementById('terrain3dBtn');
          btn.classList.remove('active');
          
          map.setTerrain(null);
          if (map.getSource('mapbox-dem')) {
            map.removeSource('mapbox-dem');
          }
        }
        
        map.flyTo({
          center: CONFIG.DEFAULT_CENTER,
          zoom: CONFIG.getDefaultZoom(),
          pitch: 0,
          bearing: 0,
          duration: 2000
        });
        
        document.querySelectorAll('.track').forEach(el => el.classList.remove('active-track'));
        
        showNotification('Map reset to default view', 2000);
      }

      getMovementDuration(track) {
        // Calculate the same duration logic used in positionMapForTrack
        const coords = [parseFloat(track.lng), parseFloat(track.lat)];
        const currentCenter = map.getCenter();
        const distance = this.calculateDistance(
          currentCenter.lat, currentCenter.lng,
          coords[1], coords[0]
        );
        
        const distanceKm = distance / 1000;
        let duration;
        if (distanceKm < 5) {
          duration = 2200;
        } else if (distanceKm < 50) {
          duration = 2200 + ((distanceKm - 5) / 45) * 1800;
        } else {
          duration = Math.min(5000, 4000 + ((distanceKm - 50) / 100) * 1000);
        }
        return duration;
      }
    }

    // Initialize controllers
    const audioController = new AudioController();
    const uiController = new UIController();
    const mapController = new MapController();

    // Initialize map data update after first load
    setTimeout(() => {
      mapController.updateMapData();
    }, 1000);

  </script>

  <script src="https://storage.ko-fi.com/cdn/scripts/overlay-widget.js"></script>
  <script>
    kofiWidgetOverlay.draw('thmkly', {
      'type': 'floating-chat',
      'floating-chat.donateButton.text': 'Support me',
      'floating-chat.donateButton.background-color': '#ff5f5f',
      'floating-chat.donateButton.text-color': '#fff'
    });
  </script>
  <style>
    .floatingchat-container-wrap {
      left: unset !important;
      right: 16px !important;
      bottom: 30px !important;
    }
    .floating-chat-kofi-popup-iframe {
      left: unset !important;
      right: 16px !important;
      bottom: 30px !important;
    }
  </style>
</body>
</html>
